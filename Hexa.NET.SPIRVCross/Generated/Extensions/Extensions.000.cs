// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SPIRV.Core;

namespace Hexa.NET.SPIRVCross
{
	public static unsafe partial class Extensions
	{
		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects. <br/>
		/// </summary>
		public static void Destroy(this SpvcContext context)
		{
			SPIRVCross.ContextDestroyNative(context);
		}

		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects, but keeps the context alive. <br/>
		/// </summary>
		public static void ReleaseAllocations(this SpvcContext context)
		{
			SPIRVCross.ContextReleaseAllocationsNative(context);
		}

		/// <summary>
		/// Get the string for the last error which was logged. <br/>
		/// </summary>
		public static byte* GetLastErrorString(this SpvcContext context)
		{
			byte* ret = SPIRVCross.ContextGetLastErrorStringNative(context);
			return ret;
		}

		/// <summary>
		/// Get the string for the last error which was logged. <br/>
		/// </summary>
		public static string GetLastErrorStringS(this SpvcContext context)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.ContextGetLastErrorStringNative(context));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetErrorCallback(this SpvcContext context, SpvcErrorCallback cb, void* userdata)
		{
			SPIRVCross.ContextSetErrorCallbackNative(context, cb, userdata);
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ParseSpirv(this SpvcContext context, uint* spirv, nuint wordCount, SpvcParsedIr* parsedIr)
		{
			SpvcResult ret = SPIRVCross.ContextParseSpirvNative(context, spirv, wordCount, parsedIr);
			return ret;
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ParseSpirv(this SpvcContext context, ref uint spirv, nuint wordCount, SpvcParsedIr* parsedIr)
		{
			fixed (uint* pspirv = &spirv)
			{
				SpvcResult ret = SPIRVCross.ContextParseSpirvNative(context, (uint*)pspirv, wordCount, parsedIr);
				return ret;
			}
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ParseSpirv(this SpvcContext context, uint* spirv, nuint wordCount, ref SpvcParsedIr parsedIr)
		{
			fixed (SpvcParsedIr* pparsedIr = &parsedIr)
			{
				SpvcResult ret = SPIRVCross.ContextParseSpirvNative(context, spirv, wordCount, (SpvcParsedIr*)pparsedIr);
				return ret;
			}
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ParseSpirv(this SpvcContext context, ref uint spirv, nuint wordCount, ref SpvcParsedIr parsedIr)
		{
			fixed (uint* pspirv = &spirv)
			{
				fixed (SpvcParsedIr* pparsedIr = &parsedIr)
				{
					SpvcResult ret = SPIRVCross.ContextParseSpirvNative(context, (uint*)pspirv, wordCount, (SpvcParsedIr*)pparsedIr);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a compiler backend. Capture mode controls if we construct by copy or move semantics.<br/>
		/// It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.<br/>
		/// </summary>
		public static SpvcResult CreateCompiler(this SpvcContext context, SpvcBackend backend, SpvcParsedIr parsedIr, SpvcCaptureMode mode, SpvcCompiler* compiler)
		{
			SpvcResult ret = SPIRVCross.ContextCreateCompilerNative(context, backend, parsedIr, mode, compiler);
			return ret;
		}

		/// <summary>
		/// Create a compiler backend. Capture mode controls if we construct by copy or move semantics.<br/>
		/// It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.<br/>
		/// </summary>
		public static SpvcResult CreateCompiler(this SpvcContext context, SpvcBackend backend, SpvcParsedIr parsedIr, SpvcCaptureMode mode, ref SpvcCompiler compiler)
		{
			fixed (SpvcCompiler* pcompiler = &compiler)
			{
				SpvcResult ret = SPIRVCross.ContextCreateCompilerNative(context, backend, parsedIr, mode, (SpvcCompiler*)pcompiler);
				return ret;
			}
		}

		/// <summary>
		/// Maps directly to C++ API. <br/>
		/// </summary>
		public static uint GetCurrentIdBound(this SpvcCompiler compiler)
		{
			uint ret = SPIRVCross.CompilerGetCurrentIdBoundNative(compiler);
			return ret;
		}

		/// <summary>
		/// Create compiler options, which will initialize defaults. <br/>
		/// </summary>
		public static SpvcResult CreateCompilerOptions(this SpvcCompiler compiler, SpvcCompilerOptions* options)
		{
			SpvcResult ret = SPIRVCross.CompilerCreateCompilerOptionsNative(compiler, options);
			return ret;
		}

		/// <summary>
		/// Create compiler options, which will initialize defaults. <br/>
		/// </summary>
		public static SpvcResult CreateCompilerOptions(this SpvcCompiler compiler, ref SpvcCompilerOptions options)
		{
			fixed (SpvcCompilerOptions* poptions = &options)
			{
				SpvcResult ret = SPIRVCross.CompilerCreateCompilerOptionsNative(compiler, (SpvcCompilerOptions*)poptions);
				return ret;
			}
		}

		/// <summary>
		/// Set compiler options. <br/>
		/// </summary>
		public static SpvcResult InstallCompilerOptions(this SpvcCompiler compiler, SpvcCompilerOptions options)
		{
			SpvcResult ret = SPIRVCross.CompilerInstallCompilerOptionsNative(compiler, options);
			return ret;
		}

		/// <summary>
		/// Compile IR into a string. *source is owned by the context, and caller must not free it themselves. <br/>
		/// </summary>
		public static SpvcResult Compile(this SpvcCompiler compiler, byte** source)
		{
			SpvcResult ret = SPIRVCross.CompilerCompileNative(compiler, source);
			return ret;
		}

		/// <summary>
		/// Compile IR into a string. *source is owned by the context, and caller must not free it themselves. <br/>
		/// </summary>
		public static SpvcResult Compile(this SpvcCompiler compiler, ref byte* source)
		{
			fixed (byte** psource = &source)
			{
				SpvcResult ret = SPIRVCross.CompilerCompileNative(compiler, (byte**)psource);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult AddHeaderLine(this SpvcCompiler compiler, byte* line)
		{
			SpvcResult ret = SPIRVCross.CompilerAddHeaderLineNative(compiler, line);
			return ret;
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult AddHeaderLine(this SpvcCompiler compiler, ref byte line)
		{
			fixed (byte* pline = &line)
			{
				SpvcResult ret = SPIRVCross.CompilerAddHeaderLineNative(compiler, (byte*)pline);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult AddHeaderLine(this SpvcCompiler compiler, ReadOnlySpan<byte> line)
		{
			fixed (byte* pline = line)
			{
				SpvcResult ret = SPIRVCross.CompilerAddHeaderLineNative(compiler, (byte*)pline);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult AddHeaderLine(this SpvcCompiler compiler, string line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (line != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(line);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(line, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerAddHeaderLineNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RequireExtension(this SpvcCompiler compiler, byte* ext)
		{
			SpvcResult ret = SPIRVCross.CompilerRequireExtensionNative(compiler, ext);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RequireExtension(this SpvcCompiler compiler, ref byte ext)
		{
			fixed (byte* pext = &ext)
			{
				SpvcResult ret = SPIRVCross.CompilerRequireExtensionNative(compiler, (byte*)pext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RequireExtension(this SpvcCompiler compiler, ReadOnlySpan<byte> ext)
		{
			fixed (byte* pext = ext)
			{
				SpvcResult ret = SPIRVCross.CompilerRequireExtensionNative(compiler, (byte*)pext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RequireExtension(this SpvcCompiler compiler, string ext)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ext != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ext);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ext, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerRequireExtensionNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint GetNumRequiredExtensions(this SpvcCompiler compiler)
		{
			nuint ret = SPIRVCross.CompilerGetNumRequiredExtensionsNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetRequiredExtension(this SpvcCompiler compiler, nuint index)
		{
			byte* ret = SPIRVCross.CompilerGetRequiredExtensionNative(compiler, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetRequiredExtensionS(this SpvcCompiler compiler, nuint index)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetRequiredExtensionNative(compiler, index));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult FlattenBufferBlock(this SpvcCompiler compiler, uint id)
		{
			SpvcResult ret = SPIRVCross.CompilerFlattenBufferBlockNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool VariableIsDepthOrCompare(this SpvcCompiler compiler, uint id)
		{
			byte ret = SPIRVCross.CompilerVariableIsDepthOrCompareNative(compiler, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MaskStageOutputByLocation(this SpvcCompiler compiler, uint location, uint component)
		{
			SpvcResult ret = SPIRVCross.CompilerMaskStageOutputByLocationNative(compiler, location, component);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MaskStageOutputByBuiltin(this SpvcCompiler compiler, SpvBuiltIn builtin)
		{
			SpvcResult ret = SPIRVCross.CompilerMaskStageOutputByBuiltinNative(compiler, builtin);
			return ret;
		}

		/// <summary>
		/// HLSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult HlslSetRootConstantsLayout(this SpvcCompiler compiler, SpvcHlslRootConstants* constantInfo, nuint count)
		{
			SpvcResult ret = SPIRVCross.CompilerHlslSetRootConstantsLayoutNative(compiler, constantInfo, count);
			return ret;
		}

		/// <summary>
		/// HLSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult HlslSetRootConstantsLayout(this SpvcCompiler compiler, ref SpvcHlslRootConstants constantInfo, nuint count)
		{
			fixed (SpvcHlslRootConstants* pconstantInfo = &constantInfo)
			{
				SpvcResult ret = SPIRVCross.CompilerHlslSetRootConstantsLayoutNative(compiler, (SpvcHlslRootConstants*)pconstantInfo, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult HlslAddVertexAttributeRemap(this SpvcCompiler compiler, SpvcHlslVertexAttributeRemap* remap, nuint remaps)
		{
			SpvcResult ret = SPIRVCross.CompilerHlslAddVertexAttributeRemapNative(compiler, remap, remaps);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult HlslAddVertexAttributeRemap(this SpvcCompiler compiler, ref SpvcHlslVertexAttributeRemap remap, nuint remaps)
		{
			fixed (SpvcHlslVertexAttributeRemap* premap = &remap)
			{
				SpvcResult ret = SPIRVCross.CompilerHlslAddVertexAttributeRemapNative(compiler, (SpvcHlslVertexAttributeRemap*)premap, remaps);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint HlslRemapNumWorkgroupsBuiltin(this SpvcCompiler compiler)
		{
			uint ret = SPIRVCross.CompilerHlslRemapNumWorkgroupsBuiltinNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult HlslSetResourceBindingFlags(this SpvcCompiler compiler, uint flags)
		{
			SpvcResult ret = SPIRVCross.CompilerHlslSetResourceBindingFlagsNative(compiler, flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult HlslAddResourceBinding(this SpvcCompiler compiler, SpvcHlslResourceBinding* binding)
		{
			SpvcResult ret = SPIRVCross.CompilerHlslAddResourceBindingNative(compiler, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult HlslAddResourceBinding(this SpvcCompiler compiler, ref SpvcHlslResourceBinding binding)
		{
			fixed (SpvcHlslResourceBinding* pbinding = &binding)
			{
				SpvcResult ret = SPIRVCross.CompilerHlslAddResourceBindingNative(compiler, (SpvcHlslResourceBinding*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HlslIsResourceUsed(this SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			byte ret = SPIRVCross.CompilerHlslIsResourceUsedNative(compiler, model, set, binding);
			return ret != 0;
		}

		/// <summary>
		/// MSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static bool MslIsRasterizationDisabled(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslIsRasterizationDisabledNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// Obsolete. Renamed to needs_swizzle_buffer. <br/>
		/// </summary>
		public static bool MslNeedsAuxBuffer(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsAuxBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslNeedsSwizzleBuffer(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsSwizzleBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslNeedsBufferSizeBuffer(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsBufferSizeBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslNeedsOutputBuffer(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsOutputBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslNeedsPatchOutputBuffer(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsPatchOutputBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslNeedsInputThreadgroupMem(this SpvcCompiler compiler)
		{
			byte ret = SPIRVCross.CompilerMslNeedsInputThreadgroupMemNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddVertexAttribute(this SpvcCompiler compiler, SpvcMslVertexAttribute* attrs)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddVertexAttributeNative(compiler, attrs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddVertexAttribute(this SpvcCompiler compiler, ref SpvcMslVertexAttribute attrs)
		{
			fixed (SpvcMslVertexAttribute* pattrs = &attrs)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddVertexAttributeNative(compiler, (SpvcMslVertexAttribute*)pattrs);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_resource_binding_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddResourceBinding(this SpvcCompiler compiler, SpvcMslResourceBinding* binding)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddResourceBindingNative(compiler, binding);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_resource_binding_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddResourceBinding(this SpvcCompiler compiler, ref SpvcMslResourceBinding binding)
		{
			fixed (SpvcMslResourceBinding* pbinding = &binding)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddResourceBindingNative(compiler, (SpvcMslResourceBinding*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddResourceBinding2(this SpvcCompiler compiler, SpvcMslResourceBinding2* binding)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddResourceBinding2Native(compiler, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddResourceBinding2(this SpvcCompiler compiler, ref SpvcMslResourceBinding2 binding)
		{
			fixed (SpvcMslResourceBinding2* pbinding = &binding)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddResourceBinding2Native(compiler, (SpvcMslResourceBinding2*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_input_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddShaderInput(this SpvcCompiler compiler, SpvcMslShaderInterfaceVar* input)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddShaderInputNative(compiler, input);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_input_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddShaderInput(this SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar input)
		{
			fixed (SpvcMslShaderInterfaceVar* pinput = &input)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddShaderInputNative(compiler, (SpvcMslShaderInterfaceVar*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddShaderInput2(this SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* input)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddShaderInput2Native(compiler, input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddShaderInput2(this SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar2 input)
		{
			fixed (SpvcMslShaderInterfaceVar2* pinput = &input)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddShaderInput2Native(compiler, (SpvcMslShaderInterfaceVar2*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_output_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddShaderOutput(this SpvcCompiler compiler, SpvcMslShaderInterfaceVar* output)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddShaderOutputNative(compiler, output);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_output_2(). <br/>
		/// </summary>
		public static SpvcResult MslAddShaderOutput(this SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar output)
		{
			fixed (SpvcMslShaderInterfaceVar* poutput = &output)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddShaderOutputNative(compiler, (SpvcMslShaderInterfaceVar*)poutput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddShaderOutput2(this SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* output)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddShaderOutput2Native(compiler, output);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddShaderOutput2(this SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar2 output)
		{
			fixed (SpvcMslShaderInterfaceVar2* poutput = &output)
			{
				SpvcResult ret = SPIRVCross.CompilerMslAddShaderOutput2Native(compiler, (SpvcMslShaderInterfaceVar2*)poutput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddDiscreteDescriptorSet(this SpvcCompiler compiler, uint descSet)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddDiscreteDescriptorSetNative(compiler, descSet);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetArgumentBufferDeviceAddressSpace(this SpvcCompiler compiler, uint descSet, bool deviceAddress)
		{
			SpvcResult ret = SPIRVCross.CompilerMslSetArgumentBufferDeviceAddressSpaceNative(compiler, descSet, deviceAddress ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Obsolete, use is_shader_input_used. <br/>
		/// </summary>
		public static bool MslIsVertexAttributeUsed(this SpvcCompiler compiler, uint location)
		{
			byte ret = SPIRVCross.CompilerMslIsVertexAttributeUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslIsShaderInputUsed(this SpvcCompiler compiler, uint location)
		{
			byte ret = SPIRVCross.CompilerMslIsShaderInputUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslIsShaderOutputUsed(this SpvcCompiler compiler, uint location)
		{
			byte ret = SPIRVCross.CompilerMslIsShaderOutputUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool MslIsResourceUsed(this SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			byte ret = SPIRVCross.CompilerMslIsResourceUsedNative(compiler, model, set, binding);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSampler(this SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler)
		{
			SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerNative(compiler, id, sampler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSampler(this SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerNative(compiler, id, (SpvcMslConstexprSampler*)psampler);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBinding(this SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler)
		{
			SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingNative(compiler, descSet, binding, sampler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBinding(this SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerYcbcr(this SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, sampler, conv);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerYcbcr(this SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, (SpvcMslConstexprSampler*)psampler, conv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerYcbcr(this SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, sampler, (SpvcMslSamplerYcbcrConversion*)pconv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerYcbcr(this SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
				{
					SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, (SpvcMslConstexprSampler*)psampler, (SpvcMslSamplerYcbcrConversion*)pconv);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBindingYcbcr(this SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, sampler, conv);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBindingYcbcr(this SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler, conv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBindingYcbcr(this SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
			{
				SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, sampler, (SpvcMslSamplerYcbcrConversion*)pconv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslRemapConstexprSamplerByBindingYcbcr(this SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
				{
					SpvcResult ret = SPIRVCross.CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler, (SpvcMslSamplerYcbcrConversion*)pconv);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetFragmentOutputComponents(this SpvcCompiler compiler, uint location, uint components)
		{
			SpvcResult ret = SPIRVCross.CompilerMslSetFragmentOutputComponentsNative(compiler, location, components);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint MslGetAutomaticResourceBinding(this SpvcCompiler compiler, uint id)
		{
			uint ret = SPIRVCross.CompilerMslGetAutomaticResourceBindingNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint MslGetAutomaticResourceBindingSecondary(this SpvcCompiler compiler, uint id)
		{
			uint ret = SPIRVCross.CompilerMslGetAutomaticResourceBindingSecondaryNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddDynamicBuffer(this SpvcCompiler compiler, uint descSet, uint binding, uint index)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddDynamicBufferNative(compiler, descSet, binding, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslAddInlineUniformBlock(this SpvcCompiler compiler, uint descSet, uint binding)
		{
			SpvcResult ret = SPIRVCross.CompilerMslAddInlineUniformBlockNative(compiler, descSet, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetCombinedSamplerSuffix(this SpvcCompiler compiler, byte* suffix)
		{
			SpvcResult ret = SPIRVCross.CompilerMslSetCombinedSamplerSuffixNative(compiler, suffix);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetCombinedSamplerSuffix(this SpvcCompiler compiler, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				SpvcResult ret = SPIRVCross.CompilerMslSetCombinedSamplerSuffixNative(compiler, (byte*)psuffix);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetCombinedSamplerSuffix(this SpvcCompiler compiler, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* psuffix = suffix)
			{
				SpvcResult ret = SPIRVCross.CompilerMslSetCombinedSamplerSuffixNative(compiler, (byte*)psuffix);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult MslSetCombinedSamplerSuffix(this SpvcCompiler compiler, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerMslSetCombinedSamplerSuffixNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* MslGetCombinedSamplerSuffix(this SpvcCompiler compiler)
		{
			byte* ret = SPIRVCross.CompilerMslGetCombinedSamplerSuffixNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string MslGetCombinedSamplerSuffixS(this SpvcCompiler compiler)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerMslGetCombinedSamplerSuffixNative(compiler));
			return ret;
		}

		/// <summary>
		/// Reflect resources.<br/>
		/// Maps almost 1:1 to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveInterfaceVariables(this SpvcCompiler compiler, SpvcSet* set)
		{
			SpvcResult ret = SPIRVCross.CompilerGetActiveInterfaceVariablesNative(compiler, set);
			return ret;
		}

		/// <summary>
		/// Reflect resources.<br/>
		/// Maps almost 1:1 to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveInterfaceVariables(this SpvcCompiler compiler, ref SpvcSet set)
		{
			fixed (SpvcSet* pset = &set)
			{
				SpvcResult ret = SPIRVCross.CompilerGetActiveInterfaceVariablesNative(compiler, (SpvcSet*)pset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetEnabledInterfaceVariables(this SpvcCompiler compiler, SpvcSet set)
		{
			SpvcResult ret = SPIRVCross.CompilerSetEnabledInterfaceVariablesNative(compiler, set);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CreateShaderResources(this SpvcCompiler compiler, SpvcResources* resources)
		{
			SpvcResult ret = SPIRVCross.CompilerCreateShaderResourcesNative(compiler, resources);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CreateShaderResources(this SpvcCompiler compiler, ref SpvcResources resources)
		{
			fixed (SpvcResources* presources = &resources)
			{
				SpvcResult ret = SPIRVCross.CompilerCreateShaderResourcesNative(compiler, (SpvcResources*)presources);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CreateShaderResourcesForActiveVariables(this SpvcCompiler compiler, SpvcResources* resources, SpvcSet active)
		{
			SpvcResult ret = SPIRVCross.CompilerCreateShaderResourcesForActiveVariablesNative(compiler, resources, active);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CreateShaderResourcesForActiveVariables(this SpvcCompiler compiler, ref SpvcResources resources, SpvcSet active)
		{
			fixed (SpvcResources* presources = &resources)
			{
				SpvcResult ret = SPIRVCross.CompilerCreateShaderResourcesForActiveVariablesNative(compiler, (SpvcResources*)presources, active);
				return ret;
			}
		}

		/// <summary>
		/// Decorations.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static void SetDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration, uint argument)
		{
			SPIRVCross.CompilerSetDecorationNative(compiler, id, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetDecorationString(this SpvcCompiler compiler, uint id, SpvDecoration decoration, byte* argument)
		{
			SPIRVCross.CompilerSetDecorationStringNative(compiler, id, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetDecorationString(this SpvcCompiler compiler, uint id, SpvDecoration decoration, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				SPIRVCross.CompilerSetDecorationStringNative(compiler, id, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetDecorationString(this SpvcCompiler compiler, uint id, SpvDecoration decoration, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				SPIRVCross.CompilerSetDecorationStringNative(compiler, id, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetDecorationString(this SpvcCompiler compiler, uint id, SpvDecoration decoration, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SPIRVCross.CompilerSetDecorationStringNative(compiler, id, decoration, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetName(this SpvcCompiler compiler, uint id, byte* argument)
		{
			SPIRVCross.CompilerSetNameNative(compiler, id, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetName(this SpvcCompiler compiler, uint id, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				SPIRVCross.CompilerSetNameNative(compiler, id, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetName(this SpvcCompiler compiler, uint id, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				SPIRVCross.CompilerSetNameNative(compiler, id, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetName(this SpvcCompiler compiler, uint id, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SPIRVCross.CompilerSetNameNative(compiler, id, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberDecoration(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, uint argument)
		{
			SPIRVCross.CompilerSetMemberDecorationNative(compiler, id, memberIndex, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberDecorationString(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, byte* argument)
		{
			SPIRVCross.CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberDecorationString(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				SPIRVCross.CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberDecorationString(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				SPIRVCross.CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberDecorationString(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SPIRVCross.CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberName(this SpvcCompiler compiler, uint id, uint memberIndex, byte* argument)
		{
			SPIRVCross.CompilerSetMemberNameNative(compiler, id, memberIndex, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberName(this SpvcCompiler compiler, uint id, uint memberIndex, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				SPIRVCross.CompilerSetMemberNameNative(compiler, id, memberIndex, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberName(this SpvcCompiler compiler, uint id, uint memberIndex, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				SPIRVCross.CompilerSetMemberNameNative(compiler, id, memberIndex, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetMemberName(this SpvcCompiler compiler, uint id, uint memberIndex, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SPIRVCross.CompilerSetMemberNameNative(compiler, id, memberIndex, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnsetDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			SPIRVCross.CompilerUnsetDecorationNative(compiler, id, decoration);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnsetMemberDecoration(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			SPIRVCross.CompilerUnsetMemberDecorationNative(compiler, id, memberIndex, decoration);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			byte ret = SPIRVCross.CompilerHasDecorationNative(compiler, id, decoration);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasMemberDecoration(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			byte ret = SPIRVCross.CompilerHasMemberDecorationNative(compiler, id, memberIndex, decoration);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetName(this SpvcCompiler compiler, uint id)
		{
			byte* ret = SPIRVCross.CompilerGetNameNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetNameS(this SpvcCompiler compiler, uint id)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetNameNative(compiler, id));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			uint ret = SPIRVCross.CompilerGetDecorationNative(compiler, id, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetDecorationString(this SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			byte* ret = SPIRVCross.CompilerGetDecorationStringNative(compiler, id, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetDecorationStringS(this SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetDecorationStringNative(compiler, id, decoration));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetMemberDecoration(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			uint ret = SPIRVCross.CompilerGetMemberDecorationNative(compiler, id, memberIndex, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetMemberDecorationString(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			byte* ret = SPIRVCross.CompilerGetMemberDecorationStringNative(compiler, id, memberIndex, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetMemberDecorationStringS(this SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetMemberDecorationStringNative(compiler, id, memberIndex, decoration));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetMemberName(this SpvcCompiler compiler, uint id, uint memberIndex)
		{
			byte* ret = SPIRVCross.CompilerGetMemberNameNative(compiler, id, memberIndex);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetMemberNameS(this SpvcCompiler compiler, uint id, uint memberIndex)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetMemberNameNative(compiler, id, memberIndex));
			return ret;
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetEntryPoints(this SpvcCompiler compiler, SpvcEntryPoint** entryPoints, nuint* numEntryPoints)
		{
			SpvcResult ret = SPIRVCross.CompilerGetEntryPointsNative(compiler, entryPoints, numEntryPoints);
			return ret;
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetEntryPoints(this SpvcCompiler compiler, ref SpvcEntryPoint* entryPoints, nuint* numEntryPoints)
		{
			fixed (SpvcEntryPoint** pentryPoints = &entryPoints)
			{
				SpvcResult ret = SPIRVCross.CompilerGetEntryPointsNative(compiler, (SpvcEntryPoint**)pentryPoints, numEntryPoints);
				return ret;
			}
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetEntryPoints(this SpvcCompiler compiler, SpvcEntryPoint** entryPoints, ref nuint numEntryPoints)
		{
			fixed (nuint* pnumEntryPoints = &numEntryPoints)
			{
				SpvcResult ret = SPIRVCross.CompilerGetEntryPointsNative(compiler, entryPoints, (nuint*)pnumEntryPoints);
				return ret;
			}
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetEntryPoints(this SpvcCompiler compiler, ref SpvcEntryPoint* entryPoints, ref nuint numEntryPoints)
		{
			fixed (SpvcEntryPoint** pentryPoints = &entryPoints)
			{
				fixed (nuint* pnumEntryPoints = &numEntryPoints)
				{
					SpvcResult ret = SPIRVCross.CompilerGetEntryPointsNative(compiler, (SpvcEntryPoint**)pentryPoints, (nuint*)pnumEntryPoints);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetEntryPoint(this SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			SpvcResult ret = SPIRVCross.CompilerSetEntryPointNative(compiler, name, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetEntryPoint(this SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				SpvcResult ret = SPIRVCross.CompilerSetEntryPointNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetEntryPoint(this SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				SpvcResult ret = SPIRVCross.CompilerSetEntryPointNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetEntryPoint(this SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerSetEntryPointNative(compiler, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, byte* oldName, byte* newName, SpvExecutionModel model)
		{
			SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, oldName, newName, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, ref byte oldName, byte* newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = &oldName)
			{
				SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, (byte*)poldName, newName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, ReadOnlySpan<byte> oldName, byte* newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = oldName)
			{
				SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, (byte*)poldName, newName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, string oldName, byte* newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, pStr0, newName, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, byte* oldName, ref byte newName, SpvExecutionModel model)
		{
			fixed (byte* pnewName = &newName)
			{
				SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, oldName, (byte*)pnewName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, byte* oldName, ReadOnlySpan<byte> newName, SpvExecutionModel model)
		{
			fixed (byte* pnewName = newName)
			{
				SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, oldName, (byte*)pnewName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, byte* oldName, string newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, oldName, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, ref byte oldName, ref byte newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = &oldName)
			{
				fixed (byte* pnewName = &newName)
				{
					SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, (byte*)poldName, (byte*)pnewName, model);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, ReadOnlySpan<byte> oldName, ReadOnlySpan<byte> newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = oldName)
			{
				fixed (byte* pnewName = newName)
				{
					SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, (byte*)poldName, (byte*)pnewName, model);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult RenameEntryPoint(this SpvcCompiler compiler, string oldName, string newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SpvcResult ret = SPIRVCross.CompilerRenameEntryPointNative(compiler, pStr0, pStr1, model);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetCleansedEntryPointName(this SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			byte* ret = SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, name, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetCleansedEntryPointNameS(this SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, name, model));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetCleansedEntryPointName(this SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetCleansedEntryPointNameS(this SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetCleansedEntryPointName(this SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				byte* ret = SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetCleansedEntryPointNameS(this SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetCleansedEntryPointName(this SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetCleansedEntryPointNameS(this SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetCleansedEntryPointNameNative(compiler, pStr0, model));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetExecutionMode(this SpvcCompiler compiler, SpvExecutionMode mode)
		{
			SPIRVCross.CompilerSetExecutionModeNative(compiler, mode);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UnsetExecutionMode(this SpvcCompiler compiler, SpvExecutionMode mode)
		{
			SPIRVCross.CompilerUnsetExecutionModeNative(compiler, mode);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetExecutionModeWithArguments(this SpvcCompiler compiler, SpvExecutionMode mode, uint arg0, uint arg1, uint arg2)
		{
			SPIRVCross.CompilerSetExecutionModeWithArgumentsNative(compiler, mode, arg0, arg1, arg2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetExecutionModes(this SpvcCompiler compiler, SpvExecutionMode** modes, nuint* numModes)
		{
			SpvcResult ret = SPIRVCross.CompilerGetExecutionModesNative(compiler, modes, numModes);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetExecutionModes(this SpvcCompiler compiler, SpvExecutionMode** modes, ref nuint numModes)
		{
			fixed (nuint* pnumModes = &numModes)
			{
				SpvcResult ret = SPIRVCross.CompilerGetExecutionModesNative(compiler, modes, (nuint*)pnumModes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetExecutionModeArgument(this SpvcCompiler compiler, SpvExecutionMode mode)
		{
			uint ret = SPIRVCross.CompilerGetExecutionModeArgumentNative(compiler, mode);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetExecutionModeArgumentByIndex(this SpvcCompiler compiler, SpvExecutionMode mode, uint index)
		{
			uint ret = SPIRVCross.CompilerGetExecutionModeArgumentByIndexNative(compiler, mode, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvExecutionModel GetExecutionModel(this SpvcCompiler compiler)
		{
			SpvExecutionModel ret = SPIRVCross.CompilerGetExecutionModelNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void UpdateActiveBuiltins(this SpvcCompiler compiler)
		{
			SPIRVCross.CompilerUpdateActiveBuiltinsNative(compiler);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool HasActiveBuiltin(this SpvcCompiler compiler, SpvBuiltIn builtin, SpvStorageClass storage)
		{
			byte ret = SPIRVCross.CompilerHasActiveBuiltinNative(compiler, builtin, storage);
			return ret != 0;
		}

		/// <summary>
		/// Type query interface.<br/>
		/// Maps to C++ API, except it's read-only.<br/>
		/// </summary>
		public static SpvcType GetTypeHandle(this SpvcCompiler compiler, uint id)
		{
			SpvcType ret = SPIRVCross.CompilerGetTypeHandleNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// Buffer layout query.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetDeclaredStructSize(this SpvcCompiler compiler, SpvcType structType, nuint* size)
		{
			SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructSizeNative(compiler, structType, size);
			return ret;
		}

		/// <summary>
		/// Buffer layout query.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetDeclaredStructSize(this SpvcCompiler compiler, SpvcType structType, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructSizeNative(compiler, structType, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredStructSizeRuntimeArray(this SpvcCompiler compiler, SpvcType structType, nuint arraySize, nuint* size)
		{
			SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructSizeRuntimeArrayNative(compiler, structType, arraySize, size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredStructSizeRuntimeArray(this SpvcCompiler compiler, SpvcType structType, nuint arraySize, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructSizeRuntimeArrayNative(compiler, structType, arraySize, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredStructMemberSize(this SpvcCompiler compiler, SpvcType type, uint index, nuint* size)
		{
			SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructMemberSizeNative(compiler, type, index, size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredStructMemberSize(this SpvcCompiler compiler, SpvcType type, uint index, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredStructMemberSizeNative(compiler, type, index, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberOffset(this SpvcCompiler compiler, SpvcType type, uint index, uint* offset)
		{
			SpvcResult ret = SPIRVCross.CompilerTypeStructMemberOffsetNative(compiler, type, index, offset);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberOffset(this SpvcCompiler compiler, SpvcType type, uint index, ref uint offset)
		{
			fixed (uint* poffset = &offset)
			{
				SpvcResult ret = SPIRVCross.CompilerTypeStructMemberOffsetNative(compiler, type, index, (uint*)poffset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberArrayStride(this SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			SpvcResult ret = SPIRVCross.CompilerTypeStructMemberArrayStrideNative(compiler, type, index, stride);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberArrayStride(this SpvcCompiler compiler, SpvcType type, uint index, ref uint stride)
		{
			fixed (uint* pstride = &stride)
			{
				SpvcResult ret = SPIRVCross.CompilerTypeStructMemberArrayStrideNative(compiler, type, index, (uint*)pstride);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberMatrixStride(this SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			SpvcResult ret = SPIRVCross.CompilerTypeStructMemberMatrixStrideNative(compiler, type, index, stride);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult TypeStructMemberMatrixStride(this SpvcCompiler compiler, SpvcType type, uint index, ref uint stride)
		{
			fixed (uint* pstride = &stride)
			{
				SpvcResult ret = SPIRVCross.CompilerTypeStructMemberMatrixStrideNative(compiler, type, index, (uint*)pstride);
				return ret;
			}
		}

		/// <summary>
		/// Workaround helper functions.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult BuildDummySamplerForCombinedImages(this SpvcCompiler compiler, uint* id)
		{
			SpvcResult ret = SPIRVCross.CompilerBuildDummySamplerForCombinedImagesNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// Workaround helper functions.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult BuildDummySamplerForCombinedImages(this SpvcCompiler compiler, ref uint id)
		{
			fixed (uint* pid = &id)
			{
				SpvcResult ret = SPIRVCross.CompilerBuildDummySamplerForCombinedImagesNative(compiler, (uint*)pid);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult BuildCombinedImageSamplers(this SpvcCompiler compiler)
		{
			SpvcResult ret = SPIRVCross.CompilerBuildCombinedImageSamplersNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetCombinedImageSamplers(this SpvcCompiler compiler, SpvcCombinedImageSampler** samplers, nuint* numSamplers)
		{
			SpvcResult ret = SPIRVCross.CompilerGetCombinedImageSamplersNative(compiler, samplers, numSamplers);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetCombinedImageSamplers(this SpvcCompiler compiler, ref SpvcCombinedImageSampler* samplers, nuint* numSamplers)
		{
			fixed (SpvcCombinedImageSampler** psamplers = &samplers)
			{
				SpvcResult ret = SPIRVCross.CompilerGetCombinedImageSamplersNative(compiler, (SpvcCombinedImageSampler**)psamplers, numSamplers);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetCombinedImageSamplers(this SpvcCompiler compiler, SpvcCombinedImageSampler** samplers, ref nuint numSamplers)
		{
			fixed (nuint* pnumSamplers = &numSamplers)
			{
				SpvcResult ret = SPIRVCross.CompilerGetCombinedImageSamplersNative(compiler, samplers, (nuint*)pnumSamplers);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetCombinedImageSamplers(this SpvcCompiler compiler, ref SpvcCombinedImageSampler* samplers, ref nuint numSamplers)
		{
			fixed (SpvcCombinedImageSampler** psamplers = &samplers)
			{
				fixed (nuint* pnumSamplers = &numSamplers)
				{
					SpvcResult ret = SPIRVCross.CompilerGetCombinedImageSamplersNative(compiler, (SpvcCombinedImageSampler**)psamplers, (nuint*)pnumSamplers);
					return ret;
				}
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant** constants, nuint* numConstants)
		{
			SpvcResult ret = SPIRVCross.CompilerGetSpecializationConstantsNative(compiler, constants, numConstants);
			return ret;
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant* constants, nuint* numConstants)
		{
			fixed (SpvcSpecializationConstant** pconstants = &constants)
			{
				SpvcResult ret = SPIRVCross.CompilerGetSpecializationConstantsNative(compiler, (SpvcSpecializationConstant**)pconstants, numConstants);
				return ret;
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant** constants, ref nuint numConstants)
		{
			fixed (nuint* pnumConstants = &numConstants)
			{
				SpvcResult ret = SPIRVCross.CompilerGetSpecializationConstantsNative(compiler, constants, (nuint*)pnumConstants);
				return ret;
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant* constants, ref nuint numConstants)
		{
			fixed (SpvcSpecializationConstant** pconstants = &constants)
			{
				fixed (nuint* pnumConstants = &numConstants)
				{
					SpvcResult ret = SPIRVCross.CompilerGetSpecializationConstantsNative(compiler, (SpvcSpecializationConstant**)pconstants, (nuint*)pnumConstants);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcConstant GetConstantHandle(this SpvcCompiler compiler, uint id)
		{
			SpvcConstant ret = SPIRVCross.CompilerGetConstantHandleNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant* x, SpvcSpecializationConstant* y, SpvcSpecializationConstant* z)
		{
			uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, y, z);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant x, SpvcSpecializationConstant* y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, y, z);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant* x, ref SpvcSpecializationConstant y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* py = &y)
			{
				uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, (SpvcSpecializationConstant*)py, z);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant x, ref SpvcSpecializationConstant y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* py = &y)
				{
					uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, (SpvcSpecializationConstant*)py, z);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant* x, SpvcSpecializationConstant* y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* pz = &z)
			{
				uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, y, (SpvcSpecializationConstant*)pz);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant x, SpvcSpecializationConstant* y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* pz = &z)
				{
					uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, y, (SpvcSpecializationConstant*)pz);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, SpvcSpecializationConstant* x, ref SpvcSpecializationConstant y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* py = &y)
			{
				fixed (SpvcSpecializationConstant* pz = &z)
				{
					uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, (SpvcSpecializationConstant*)py, (SpvcSpecializationConstant*)pz);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetWorkGroupSizeSpecializationConstants(this SpvcCompiler compiler, ref SpvcSpecializationConstant x, ref SpvcSpecializationConstant y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* py = &y)
				{
					fixed (SpvcSpecializationConstant* pz = &z)
					{
						uint ret = SPIRVCross.CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, (SpvcSpecializationConstant*)py, (SpvcSpecializationConstant*)pz);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveBufferRanges(this SpvcCompiler compiler, uint id, SpvcBufferRange** ranges, nuint* numRanges)
		{
			SpvcResult ret = SPIRVCross.CompilerGetActiveBufferRangesNative(compiler, id, ranges, numRanges);
			return ret;
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveBufferRanges(this SpvcCompiler compiler, uint id, ref SpvcBufferRange* ranges, nuint* numRanges)
		{
			fixed (SpvcBufferRange** pranges = &ranges)
			{
				SpvcResult ret = SPIRVCross.CompilerGetActiveBufferRangesNative(compiler, id, (SpvcBufferRange**)pranges, numRanges);
				return ret;
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveBufferRanges(this SpvcCompiler compiler, uint id, SpvcBufferRange** ranges, ref nuint numRanges)
		{
			fixed (nuint* pnumRanges = &numRanges)
			{
				SpvcResult ret = SPIRVCross.CompilerGetActiveBufferRangesNative(compiler, id, ranges, (nuint*)pnumRanges);
				return ret;
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult GetActiveBufferRanges(this SpvcCompiler compiler, uint id, ref SpvcBufferRange* ranges, ref nuint numRanges)
		{
			fixed (SpvcBufferRange** pranges = &ranges)
			{
				fixed (nuint* pnumRanges = &numRanges)
				{
					SpvcResult ret = SPIRVCross.CompilerGetActiveBufferRangesNative(compiler, id, (SpvcBufferRange**)pranges, (nuint*)pnumRanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// Misc reflection<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static bool GetBinaryOffsetForDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration, uint* wordOffset)
		{
			byte ret = SPIRVCross.CompilerGetBinaryOffsetForDecorationNative(compiler, id, decoration, wordOffset);
			return ret != 0;
		}

		/// <summary>
		/// Misc reflection<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static bool GetBinaryOffsetForDecoration(this SpvcCompiler compiler, uint id, SpvDecoration decoration, ref uint wordOffset)
		{
			fixed (uint* pwordOffset = &wordOffset)
			{
				byte ret = SPIRVCross.CompilerGetBinaryOffsetForDecorationNative(compiler, id, decoration, (uint*)pwordOffset);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BufferIsHlslCounterBuffer(this SpvcCompiler compiler, uint id)
		{
			byte ret = SPIRVCross.CompilerBufferIsHlslCounterBufferNative(compiler, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BufferGetHlslCounterBuffer(this SpvcCompiler compiler, uint id, uint* counterId)
		{
			byte ret = SPIRVCross.CompilerBufferGetHlslCounterBufferNative(compiler, id, counterId);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool BufferGetHlslCounterBuffer(this SpvcCompiler compiler, uint id, ref uint counterId)
		{
			fixed (uint* pcounterId = &counterId)
			{
				byte ret = SPIRVCross.CompilerBufferGetHlslCounterBufferNative(compiler, id, (uint*)pcounterId);
				return ret != 0;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredCapabilities(this SpvcCompiler compiler, SpvCapability** capabilities, nuint* numCapabilities)
		{
			SpvcResult ret = SPIRVCross.CompilerGetDeclaredCapabilitiesNative(compiler, capabilities, numCapabilities);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredCapabilities(this SpvcCompiler compiler, SpvCapability** capabilities, ref nuint numCapabilities)
		{
			fixed (nuint* pnumCapabilities = &numCapabilities)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredCapabilitiesNative(compiler, capabilities, (nuint*)pnumCapabilities);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredExtensions(this SpvcCompiler compiler, byte*** extensions, nuint* numExtensions)
		{
			SpvcResult ret = SPIRVCross.CompilerGetDeclaredExtensionsNative(compiler, extensions, numExtensions);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredExtensions(this SpvcCompiler compiler, ref byte** extensions, nuint* numExtensions)
		{
			fixed (byte*** pextensions = &extensions)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredExtensionsNative(compiler, (byte***)pextensions, numExtensions);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredExtensions(this SpvcCompiler compiler, byte*** extensions, ref nuint numExtensions)
		{
			fixed (nuint* pnumExtensions = &numExtensions)
			{
				SpvcResult ret = SPIRVCross.CompilerGetDeclaredExtensionsNative(compiler, extensions, (nuint*)pnumExtensions);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetDeclaredExtensions(this SpvcCompiler compiler, ref byte** extensions, ref nuint numExtensions)
		{
			fixed (byte*** pextensions = &extensions)
			{
				fixed (nuint* pnumExtensions = &numExtensions)
				{
					SpvcResult ret = SPIRVCross.CompilerGetDeclaredExtensionsNative(compiler, (byte***)pextensions, (nuint*)pnumExtensions);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetRemappedDeclaredBlockName(this SpvcCompiler compiler, uint id)
		{
			byte* ret = SPIRVCross.CompilerGetRemappedDeclaredBlockNameNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetRemappedDeclaredBlockNameS(this SpvcCompiler compiler, uint id)
		{
			string ret = Utils.DecodeStringUTF8(SPIRVCross.CompilerGetRemappedDeclaredBlockNameNative(compiler, id));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBufferBlockDecorations(this SpvcCompiler compiler, uint id, SpvDecoration** decorations, nuint* numDecorations)
		{
			SpvcResult ret = SPIRVCross.CompilerGetBufferBlockDecorationsNative(compiler, id, decorations, numDecorations);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBufferBlockDecorations(this SpvcCompiler compiler, uint id, SpvDecoration** decorations, ref nuint numDecorations)
		{
			fixed (nuint* pnumDecorations = &numDecorations)
			{
				SpvcResult ret = SPIRVCross.CompilerGetBufferBlockDecorationsNative(compiler, id, decorations, (nuint*)pnumDecorations);
				return ret;
			}
		}

		/// <summary>
		/// Override options. Will return error if e.g. MSL options are used for the HLSL backend, etc. <br/>
		/// </summary>
		public static SpvcResult SetBool(this SpvcCompilerOptions options, SpvcCompilerOption option, bool value)
		{
			SpvcResult ret = SPIRVCross.CompilerOptionsSetBoolNative(options, option, value ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult SetUint(this SpvcCompilerOptions options, SpvcCompilerOption option, uint value)
		{
			SpvcResult ret = SPIRVCross.CompilerOptionsSetUintNative(options, option, value);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetResourceListForType(this SpvcResources resources, SpvcResourceType type, SpvcReflectedResource** resourceList, nuint* resourceSize)
		{
			SpvcResult ret = SPIRVCross.ResourcesGetResourceListForTypeNative(resources, type, resourceList, resourceSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetResourceListForType(this SpvcResources resources, SpvcResourceType type, ref SpvcReflectedResource* resourceList, nuint* resourceSize)
		{
			fixed (SpvcReflectedResource** presourceList = &resourceList)
			{
				SpvcResult ret = SPIRVCross.ResourcesGetResourceListForTypeNative(resources, type, (SpvcReflectedResource**)presourceList, resourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetResourceListForType(this SpvcResources resources, SpvcResourceType type, SpvcReflectedResource** resourceList, ref nuint resourceSize)
		{
			fixed (nuint* presourceSize = &resourceSize)
			{
				SpvcResult ret = SPIRVCross.ResourcesGetResourceListForTypeNative(resources, type, resourceList, (nuint*)presourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetResourceListForType(this SpvcResources resources, SpvcResourceType type, ref SpvcReflectedResource* resourceList, ref nuint resourceSize)
		{
			fixed (SpvcReflectedResource** presourceList = &resourceList)
			{
				fixed (nuint* presourceSize = &resourceSize)
				{
					SpvcResult ret = SPIRVCross.ResourcesGetResourceListForTypeNative(resources, type, (SpvcReflectedResource**)presourceList, (nuint*)presourceSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBuiltinResourceListForType(this SpvcResources resources, SpvcBuiltinResourceType type, SpvcReflectedBuiltinResource** resourceList, nuint* resourceSize)
		{
			SpvcResult ret = SPIRVCross.ResourcesGetBuiltinResourceListForTypeNative(resources, type, resourceList, resourceSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBuiltinResourceListForType(this SpvcResources resources, SpvcBuiltinResourceType type, ref SpvcReflectedBuiltinResource* resourceList, nuint* resourceSize)
		{
			fixed (SpvcReflectedBuiltinResource** presourceList = &resourceList)
			{
				SpvcResult ret = SPIRVCross.ResourcesGetBuiltinResourceListForTypeNative(resources, type, (SpvcReflectedBuiltinResource**)presourceList, resourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBuiltinResourceListForType(this SpvcResources resources, SpvcBuiltinResourceType type, SpvcReflectedBuiltinResource** resourceList, ref nuint resourceSize)
		{
			fixed (nuint* presourceSize = &resourceSize)
			{
				SpvcResult ret = SPIRVCross.ResourcesGetBuiltinResourceListForTypeNative(resources, type, resourceList, (nuint*)presourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult GetBuiltinResourceListForType(this SpvcResources resources, SpvcBuiltinResourceType type, ref SpvcReflectedBuiltinResource* resourceList, ref nuint resourceSize)
		{
			fixed (SpvcReflectedBuiltinResource** presourceList = &resourceList)
			{
				fixed (nuint* presourceSize = &resourceSize)
				{
					SpvcResult ret = SPIRVCross.ResourcesGetBuiltinResourceListForTypeNative(resources, type, (SpvcReflectedBuiltinResource**)presourceList, (nuint*)presourceSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Pulls out SPIRType::self. This effectively gives the type ID without array or pointer qualifiers.<br/>
		/// This is necessary when reflecting decoration/name information on members of a struct,<br/>
		/// which are placed in the base type, not the qualified type.<br/>
		/// This is similar to spvc_reflected_resource::base_type_id. <br/>
		/// </summary>
		public static uint GetBaseTypeId(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetBaseTypeIdNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcBasetype GetBasetype(this SpvcType type)
		{
			SpvcBasetype ret = SPIRVCross.TypeGetBasetypeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetBitWidth(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetBitWidthNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetVectorSize(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetVectorSizeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetColumns(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetColumnsNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetNumArrayDimensions(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetNumArrayDimensionsNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ArrayDimensionIsLiteral(this SpvcType type, uint dimension)
		{
			byte ret = SPIRVCross.TypeArrayDimensionIsLiteralNative(type, dimension);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetArrayDimension(this SpvcType type, uint dimension)
		{
			uint ret = SPIRVCross.TypeGetArrayDimensionNative(type, dimension);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetNumMemberTypes(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetNumMemberTypesNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetMemberType(this SpvcType type, uint index)
		{
			uint ret = SPIRVCross.TypeGetMemberTypeNative(type, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvStorageClass GetStorageClass(this SpvcType type)
		{
			SpvStorageClass ret = SPIRVCross.TypeGetStorageClassNative(type);
			return ret;
		}

		/// <summary>
		/// Image type query. <br/>
		/// </summary>
		public static uint GetImageSampledType(this SpvcType type)
		{
			uint ret = SPIRVCross.TypeGetImageSampledTypeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvDim GetImageDimension(this SpvcType type)
		{
			SpvDim ret = SPIRVCross.TypeGetImageDimensionNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetImageIsDepth(this SpvcType type)
		{
			byte ret = SPIRVCross.TypeGetImageIsDepthNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetImageArrayed(this SpvcType type)
		{
			byte ret = SPIRVCross.TypeGetImageArrayedNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetImageMultisampled(this SpvcType type)
		{
			byte ret = SPIRVCross.TypeGetImageMultisampledNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool GetImageIsStorage(this SpvcType type)
		{
			byte ret = SPIRVCross.TypeGetImageIsStorageNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvImageFormat GetImageStorageFormat(this SpvcType type)
		{
			SpvImageFormat ret = SPIRVCross.TypeGetImageStorageFormatNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvAccessQualifier GetImageAccessQualifier(this SpvcType type)
		{
			SpvAccessQualifier ret = SPIRVCross.TypeGetImageAccessQualifierNative(type);
			return ret;
		}

		/// <summary>
		/// No stdint.h until C99, sigh :(<br/>
		/// For smaller types, the result is sign or zero-extended as appropriate.<br/>
		/// Maps to C++ API.<br/>
		/// TODO: The SPIRConstant query interface and modification interface is not quite complete.<br/>
		/// </summary>
		public static float GetScalarFp16(this SpvcConstant constant, uint column, uint row)
		{
			float ret = SPIRVCross.ConstantGetScalarFp16Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float GetScalarFp32(this SpvcConstant constant, uint column, uint row)
		{
			float ret = SPIRVCross.ConstantGetScalarFp32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double GetScalarFp64(this SpvcConstant constant, uint column, uint row)
		{
			double ret = SPIRVCross.ConstantGetScalarFp64Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetScalarU32(this SpvcConstant constant, uint column, uint row)
		{
			uint ret = SPIRVCross.ConstantGetScalarU32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetScalarI32(this SpvcConstant constant, uint column, uint row)
		{
			int ret = SPIRVCross.ConstantGetScalarI32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetScalarU16(this SpvcConstant constant, uint column, uint row)
		{
			uint ret = SPIRVCross.ConstantGetScalarU16Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetScalarI16(this SpvcConstant constant, uint column, uint row)
		{
			int ret = SPIRVCross.ConstantGetScalarI16Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetScalarU8(this SpvcConstant constant, uint column, uint row)
		{
			uint ret = SPIRVCross.ConstantGetScalarU8Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int GetScalarI8(this SpvcConstant constant, uint column, uint row)
		{
			int ret = SPIRVCross.ConstantGetScalarI8Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSubconstants(this SpvcConstant constant, uint** constituents, nuint* count)
		{
			SPIRVCross.ConstantGetSubconstantsNative(constant, constituents, count);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSubconstants(this SpvcConstant constant, ref uint* constituents, nuint* count)
		{
			fixed (uint** pconstituents = &constituents)
			{
				SPIRVCross.ConstantGetSubconstantsNative(constant, (uint**)pconstituents, count);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSubconstants(this SpvcConstant constant, uint** constituents, ref nuint count)
		{
			fixed (nuint* pcount = &count)
			{
				SPIRVCross.ConstantGetSubconstantsNative(constant, constituents, (nuint*)pcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetSubconstants(this SpvcConstant constant, ref uint* constituents, ref nuint count)
		{
			fixed (uint** pconstituents = &constituents)
			{
				fixed (nuint* pcount = &count)
				{
					SPIRVCross.ConstantGetSubconstantsNative(constant, (uint**)pconstituents, (nuint*)pcount);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong GetScalarU64(this SpvcConstant constant, uint column, uint row)
		{
			ulong ret = SPIRVCross.ConstantGetScalarU64Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static long GetScalarI64(this SpvcConstant constant, uint column, uint row)
		{
			long ret = SPIRVCross.ConstantGetScalarI64Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint GetType(this SpvcConstant constant)
		{
			uint ret = SPIRVCross.ConstantGetTypeNative(constant);
			return ret;
		}

		/// <summary>
		/// C implementation of the C++ api.<br/>
		/// </summary>
		public static void SetScalarFp16(this SpvcConstant constant, uint column, uint row, ushort value)
		{
			SPIRVCross.ConstantSetScalarFp16Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarFp32(this SpvcConstant constant, uint column, uint row, float value)
		{
			SPIRVCross.ConstantSetScalarFp32Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarFp64(this SpvcConstant constant, uint column, uint row, double value)
		{
			SPIRVCross.ConstantSetScalarFp64Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarU32(this SpvcConstant constant, uint column, uint row, uint value)
		{
			SPIRVCross.ConstantSetScalarU32Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarI32(this SpvcConstant constant, uint column, uint row, int value)
		{
			SPIRVCross.ConstantSetScalarI32Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarU64(this SpvcConstant constant, uint column, uint row, ulong value)
		{
			SPIRVCross.ConstantSetScalarU64Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarI64(this SpvcConstant constant, uint column, uint row, long value)
		{
			SPIRVCross.ConstantSetScalarI64Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarU16(this SpvcConstant constant, uint column, uint row, ushort value)
		{
			SPIRVCross.ConstantSetScalarU16Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarI16(this SpvcConstant constant, uint column, uint row, short value)
		{
			SPIRVCross.ConstantSetScalarI16Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarU8(this SpvcConstant constant, uint column, uint row, byte value)
		{
			SPIRVCross.ConstantSetScalarU8Native(constant, column, row, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetScalarI8(this SpvcConstant constant, uint column, uint row, byte value)
		{
			SPIRVCross.ConstantSetScalarI8Native(constant, column, row, value);
		}

	}
}
