// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SPIRV.Core;

namespace Hexa.NET.SPIRVCross
{
	public unsafe partial class SPIRVCross
	{
		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVersionNative(uint* major, uint* minor, uint* patch)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, uint*, uint*, void>)funcTable[0])(major, minor, patch);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[0])((nint)major, (nint)minor, (nint)patch);
			#endif
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(uint* major, uint* minor, uint* patch)
		{
			GetVersionNative(major, minor, patch);
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(ref uint major, uint* minor, uint* patch)
		{
			fixed (uint* pmajor = &major)
			{
				GetVersionNative((uint*)pmajor, minor, patch);
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(uint* major, ref uint minor, uint* patch)
		{
			fixed (uint* pminor = &minor)
			{
				GetVersionNative(major, (uint*)pminor, patch);
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(ref uint major, ref uint minor, uint* patch)
		{
			fixed (uint* pmajor = &major)
			{
				fixed (uint* pminor = &minor)
				{
					GetVersionNative((uint*)pmajor, (uint*)pminor, patch);
				}
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(uint* major, uint* minor, ref uint patch)
		{
			fixed (uint* ppatch = &patch)
			{
				GetVersionNative(major, minor, (uint*)ppatch);
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(ref uint major, uint* minor, ref uint patch)
		{
			fixed (uint* pmajor = &major)
			{
				fixed (uint* ppatch = &patch)
				{
					GetVersionNative((uint*)pmajor, minor, (uint*)ppatch);
				}
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(uint* major, ref uint minor, ref uint patch)
		{
			fixed (uint* pminor = &minor)
			{
				fixed (uint* ppatch = &patch)
				{
					GetVersionNative(major, (uint*)pminor, (uint*)ppatch);
				}
			}
		}

		/// <summary>
		/// Gets the SPVC_C_API_VERSION_* used to build this library.<br/>
		/// Can be used to check for ABI mismatch if so-versioning did not catch it.<br/>
		/// </summary>
		public static void GetVersion(ref uint major, ref uint minor, ref uint patch)
		{
			fixed (uint* pmajor = &major)
			{
				fixed (uint* pminor = &minor)
				{
					fixed (uint* ppatch = &patch)
					{
						GetVersionNative((uint*)pmajor, (uint*)pminor, (uint*)ppatch);
					}
				}
			}
		}

		/// <summary>
		/// Gets a human readable version string to identify which commit a particular binary was created from. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetCommitRevisionAndTimestampNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[1])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[1])();
			#endif
		}

		/// <summary>
		/// Gets a human readable version string to identify which commit a particular binary was created from. <br/>
		/// </summary>
		public static byte* GetCommitRevisionAndTimestamp()
		{
			byte* ret = GetCommitRevisionAndTimestampNative();
			return ret;
		}

		/// <summary>
		/// Gets a human readable version string to identify which commit a particular binary was created from. <br/>
		/// </summary>
		public static string GetCommitRevisionAndTimestampS()
		{
			string ret = Utils.DecodeStringUTF8(GetCommitRevisionAndTimestampNative());
			return ret;
		}

		/// <summary>
		/// Initializes the vertex attribute struct.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslVertexAttributeInitNative(SpvcMslVertexAttribute* attr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslVertexAttribute*, void>)funcTable[2])(attr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[2])((nint)attr);
			#endif
		}

		/// <summary>
		/// Initializes the vertex attribute struct.<br/>
		/// </summary>
		public static void MslVertexAttributeInit(SpvcMslVertexAttribute* attr)
		{
			MslVertexAttributeInitNative(attr);
		}

		/// <summary>
		/// Initializes the vertex attribute struct.<br/>
		/// </summary>
		public static void MslVertexAttributeInit(ref SpvcMslVertexAttribute attr)
		{
			fixed (SpvcMslVertexAttribute* pattr = &attr)
			{
				MslVertexAttributeInitNative((SpvcMslVertexAttribute*)pattr);
			}
		}

		/// <summary>
		/// Initializes the shader input struct.<br/>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslShaderInterfaceVarInitNative(SpvcMslShaderInterfaceVar* var)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslShaderInterfaceVar*, void>)funcTable[3])(var);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[3])((nint)var);
			#endif
		}

		/// <summary>
		/// Initializes the shader input struct.<br/>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		public static void MslShaderInterfaceVarInit(SpvcMslShaderInterfaceVar* var)
		{
			MslShaderInterfaceVarInitNative(var);
		}

		/// <summary>
		/// Initializes the shader input struct.<br/>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		public static void MslShaderInterfaceVarInit(ref SpvcMslShaderInterfaceVar var)
		{
			fixed (SpvcMslShaderInterfaceVar* pvar = &var)
			{
				MslShaderInterfaceVarInitNative((SpvcMslShaderInterfaceVar*)pvar);
			}
		}

		/// <summary>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslShaderInputInitNative(SpvcMslShaderInterfaceVar* input)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslShaderInterfaceVar*, void>)funcTable[4])(input);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[4])((nint)input);
			#endif
		}

		/// <summary>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		public static void MslShaderInputInit(SpvcMslShaderInterfaceVar* input)
		{
			MslShaderInputInitNative(input);
		}

		/// <summary>
		/// Deprecated. Use spvc_msl_shader_interface_var_init_2().<br/>
		/// </summary>
		public static void MslShaderInputInit(ref SpvcMslShaderInterfaceVar input)
		{
			fixed (SpvcMslShaderInterfaceVar* pinput = &input)
			{
				MslShaderInputInitNative((SpvcMslShaderInterfaceVar*)pinput);
			}
		}

		/// <summary>
		/// Initializes the shader interface variable struct.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslShaderInterfaceVarInit2Native(SpvcMslShaderInterfaceVar2* var)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslShaderInterfaceVar2*, void>)funcTable[5])(var);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[5])((nint)var);
			#endif
		}

		/// <summary>
		/// Initializes the shader interface variable struct.<br/>
		/// </summary>
		public static void MslShaderInterfaceVarInit2(SpvcMslShaderInterfaceVar2* var)
		{
			MslShaderInterfaceVarInit2Native(var);
		}

		/// <summary>
		/// Initializes the shader interface variable struct.<br/>
		/// </summary>
		public static void MslShaderInterfaceVarInit2(ref SpvcMslShaderInterfaceVar2 var)
		{
			fixed (SpvcMslShaderInterfaceVar2* pvar = &var)
			{
				MslShaderInterfaceVarInit2Native((SpvcMslShaderInterfaceVar2*)pvar);
			}
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// Deprecated: Use spvc_msl_resource_binding_init_2.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslResourceBindingInitNative(SpvcMslResourceBinding* binding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslResourceBinding*, void>)funcTable[6])(binding);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[6])((nint)binding);
			#endif
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// Deprecated: Use spvc_msl_resource_binding_init_2.<br/>
		/// </summary>
		public static void MslResourceBindingInit(SpvcMslResourceBinding* binding)
		{
			MslResourceBindingInitNative(binding);
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// Deprecated: Use spvc_msl_resource_binding_init_2.<br/>
		/// </summary>
		public static void MslResourceBindingInit(ref SpvcMslResourceBinding binding)
		{
			fixed (SpvcMslResourceBinding* pbinding = &binding)
			{
				MslResourceBindingInitNative((SpvcMslResourceBinding*)pbinding);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslResourceBindingInit2Native(SpvcMslResourceBinding2* binding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslResourceBinding2*, void>)funcTable[7])(binding);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[7])((nint)binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MslResourceBindingInit2(SpvcMslResourceBinding2* binding)
		{
			MslResourceBindingInit2Native(binding);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MslResourceBindingInit2(ref SpvcMslResourceBinding2 binding)
		{
			fixed (SpvcMslResourceBinding2* pbinding = &binding)
			{
				MslResourceBindingInit2Native((SpvcMslResourceBinding2*)pbinding);
			}
		}

		/// <summary>
		/// Runtime check for incompatibility. Obsolete. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint MslGetAuxBufferStructVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[8])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[8])();
			#endif
		}

		/// <summary>
		/// Runtime check for incompatibility. Obsolete. <br/>
		/// </summary>
		public static uint MslGetAuxBufferStructVersion()
		{
			uint ret = MslGetAuxBufferStructVersionNative();
			return ret;
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslConstexprSamplerInitNative(SpvcMslConstexprSampler* sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslConstexprSampler*, void>)funcTable[9])(sampler);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[9])((nint)sampler);
			#endif
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void MslConstexprSamplerInit(SpvcMslConstexprSampler* sampler)
		{
			MslConstexprSamplerInitNative(sampler);
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void MslConstexprSamplerInit(ref SpvcMslConstexprSampler sampler)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				MslConstexprSamplerInitNative((SpvcMslConstexprSampler*)psampler);
			}
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MslSamplerYcbcrConversionInitNative(SpvcMslSamplerYcbcrConversion* conv)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcMslSamplerYcbcrConversion*, void>)funcTable[10])(conv);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[10])((nint)conv);
			#endif
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void MslSamplerYcbcrConversionInit(SpvcMslSamplerYcbcrConversion* conv)
		{
			MslSamplerYcbcrConversionInitNative(conv);
		}

		/// <summary>
		/// Initializes the constexpr sampler struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void MslSamplerYcbcrConversionInit(ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
			{
				MslSamplerYcbcrConversionInitNative((SpvcMslSamplerYcbcrConversion*)pconv);
			}
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HlslResourceBindingInitNative(SpvcHlslResourceBinding* binding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcHlslResourceBinding*, void>)funcTable[11])(binding);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[11])((nint)binding);
			#endif
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void HlslResourceBindingInit(SpvcHlslResourceBinding* binding)
		{
			HlslResourceBindingInitNative(binding);
		}

		/// <summary>
		/// Initializes the resource binding struct.<br/>
		/// The defaults are non-zero.<br/>
		/// </summary>
		public static void HlslResourceBindingInit(ref SpvcHlslResourceBinding binding)
		{
			fixed (SpvcHlslResourceBinding* pbinding = &binding)
			{
				HlslResourceBindingInitNative((SpvcHlslResourceBinding*)pbinding);
			}
		}

		/// <summary>
		/// Context is the highest-level API construct.<br/>
		/// The context owns all memory allocations made by its child object hierarchy, including various non-opaque structs and strings.<br/>
		/// This means that the API user only has to care about one "destroy" call ever when using the C API.<br/>
		/// All pointers handed out by the APIs are only valid as long as the context<br/>
		/// is alive and spvc_context_release_allocations has not been called.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult ContextCreateNative(SpvcContext* context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcContext*, SpvcResult>)funcTable[12])(context);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<nint, SpvcResult>)funcTable[12])((nint)context);
			#endif
		}

		/// <summary>
		/// Context is the highest-level API construct.<br/>
		/// The context owns all memory allocations made by its child object hierarchy, including various non-opaque structs and strings.<br/>
		/// This means that the API user only has to care about one "destroy" call ever when using the C API.<br/>
		/// All pointers handed out by the APIs are only valid as long as the context<br/>
		/// is alive and spvc_context_release_allocations has not been called.<br/>
		/// </summary>
		public static SpvcResult ContextCreate(SpvcContext* context)
		{
			SpvcResult ret = ContextCreateNative(context);
			return ret;
		}

		/// <summary>
		/// Context is the highest-level API construct.<br/>
		/// The context owns all memory allocations made by its child object hierarchy, including various non-opaque structs and strings.<br/>
		/// This means that the API user only has to care about one "destroy" call ever when using the C API.<br/>
		/// All pointers handed out by the APIs are only valid as long as the context<br/>
		/// is alive and spvc_context_release_allocations has not been called.<br/>
		/// </summary>
		public static SpvcResult ContextCreate(ref SpvcContext context)
		{
			fixed (SpvcContext* pcontext = &context)
			{
				SpvcResult ret = ContextCreateNative((SpvcContext*)pcontext);
				return ret;
			}
		}

		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ContextDestroyNative(SpvcContext context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcContext, void>)funcTable[13])(context);
			#else
			((delegate* unmanaged[Cdecl]<SpvcContext, void>)funcTable[13])(context);
			#endif
		}

		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects. <br/>
		/// </summary>
		public static void ContextDestroy(SpvcContext context)
		{
			ContextDestroyNative(context);
		}

		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects, but keeps the context alive. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ContextReleaseAllocationsNative(SpvcContext context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcContext, void>)funcTable[14])(context);
			#else
			((delegate* unmanaged[Cdecl]<SpvcContext, void>)funcTable[14])(context);
			#endif
		}

		/// <summary>
		/// Frees all memory allocations and objects associated with the context and its child objects, but keeps the context alive. <br/>
		/// </summary>
		public static void ContextReleaseAllocations(SpvcContext context)
		{
			ContextReleaseAllocationsNative(context);
		}

		/// <summary>
		/// Get the string for the last error which was logged. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ContextGetLastErrorStringNative(SpvcContext context)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcContext, byte*>)funcTable[15])(context);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcContext, nint>)funcTable[15])(context);
			#endif
		}

		/// <summary>
		/// Get the string for the last error which was logged. <br/>
		/// </summary>
		public static byte* ContextGetLastErrorString(SpvcContext context)
		{
			byte* ret = ContextGetLastErrorStringNative(context);
			return ret;
		}

		/// <summary>
		/// Get the string for the last error which was logged. <br/>
		/// </summary>
		public static string ContextGetLastErrorStringS(SpvcContext context)
		{
			string ret = Utils.DecodeStringUTF8(ContextGetLastErrorStringNative(context));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ContextSetErrorCallbackNative(SpvcContext context, SpvcErrorCallback cb, void* userdata)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcContext, delegate*<void*, byte*, void>, void*, void>)funcTable[16])(context, (delegate*<void*, byte*, void>)Utils.GetFunctionPointerForDelegate(cb), userdata);
			#else
			((delegate* unmanaged[Cdecl]<SpvcContext, nint, nint, void>)funcTable[16])(context, (nint)Utils.GetFunctionPointerForDelegate(cb), (nint)userdata);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ContextSetErrorCallback(SpvcContext context, SpvcErrorCallback cb, void* userdata)
		{
			ContextSetErrorCallbackNative(context, cb, userdata);
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult ContextParseSpirvNative(SpvcContext context, uint* spirv, nuint wordCount, SpvcParsedIr* parsedIr)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcContext, uint*, nuint, SpvcParsedIr*, SpvcResult>)funcTable[17])(context, spirv, wordCount, parsedIr);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcContext, nint, nuint, nint, SpvcResult>)funcTable[17])(context, (nint)spirv, wordCount, (nint)parsedIr);
			#endif
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ContextParseSpirv(SpvcContext context, uint* spirv, nuint wordCount, SpvcParsedIr* parsedIr)
		{
			SpvcResult ret = ContextParseSpirvNative(context, spirv, wordCount, parsedIr);
			return ret;
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ContextParseSpirv(SpvcContext context, ref uint spirv, nuint wordCount, SpvcParsedIr* parsedIr)
		{
			fixed (uint* pspirv = &spirv)
			{
				SpvcResult ret = ContextParseSpirvNative(context, (uint*)pspirv, wordCount, parsedIr);
				return ret;
			}
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ContextParseSpirv(SpvcContext context, uint* spirv, nuint wordCount, ref SpvcParsedIr parsedIr)
		{
			fixed (SpvcParsedIr* pparsedIr = &parsedIr)
			{
				SpvcResult ret = ContextParseSpirvNative(context, spirv, wordCount, (SpvcParsedIr*)pparsedIr);
				return ret;
			}
		}

		/// <summary>
		/// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle. <br/>
		/// </summary>
		public static SpvcResult ContextParseSpirv(SpvcContext context, ref uint spirv, nuint wordCount, ref SpvcParsedIr parsedIr)
		{
			fixed (uint* pspirv = &spirv)
			{
				fixed (SpvcParsedIr* pparsedIr = &parsedIr)
				{
					SpvcResult ret = ContextParseSpirvNative(context, (uint*)pspirv, wordCount, (SpvcParsedIr*)pparsedIr);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a compiler backend. Capture mode controls if we construct by copy or move semantics.<br/>
		/// It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult ContextCreateCompilerNative(SpvcContext context, SpvcBackend backend, SpvcParsedIr parsedIr, SpvcCaptureMode mode, SpvcCompiler* compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcContext, SpvcBackend, SpvcParsedIr, SpvcCaptureMode, SpvcCompiler*, SpvcResult>)funcTable[18])(context, backend, parsedIr, mode, compiler);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcContext, SpvcBackend, SpvcParsedIr, SpvcCaptureMode, nint, SpvcResult>)funcTable[18])(context, backend, parsedIr, mode, (nint)compiler);
			#endif
		}

		/// <summary>
		/// Create a compiler backend. Capture mode controls if we construct by copy or move semantics.<br/>
		/// It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.<br/>
		/// </summary>
		public static SpvcResult ContextCreateCompiler(SpvcContext context, SpvcBackend backend, SpvcParsedIr parsedIr, SpvcCaptureMode mode, SpvcCompiler* compiler)
		{
			SpvcResult ret = ContextCreateCompilerNative(context, backend, parsedIr, mode, compiler);
			return ret;
		}

		/// <summary>
		/// Create a compiler backend. Capture mode controls if we construct by copy or move semantics.<br/>
		/// It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.<br/>
		/// </summary>
		public static SpvcResult ContextCreateCompiler(SpvcContext context, SpvcBackend backend, SpvcParsedIr parsedIr, SpvcCaptureMode mode, ref SpvcCompiler compiler)
		{
			fixed (SpvcCompiler* pcompiler = &compiler)
			{
				SpvcResult ret = ContextCreateCompilerNative(context, backend, parsedIr, mode, (SpvcCompiler*)pcompiler);
				return ret;
			}
		}

		/// <summary>
		/// Maps directly to C++ API. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetCurrentIdBoundNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint>)funcTable[19])(compiler);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint>)funcTable[19])(compiler);
			#endif
		}

		/// <summary>
		/// Maps directly to C++ API. <br/>
		/// </summary>
		public static uint CompilerGetCurrentIdBound(SpvcCompiler compiler)
		{
			uint ret = CompilerGetCurrentIdBoundNative(compiler);
			return ret;
		}

		/// <summary>
		/// Create compiler options, which will initialize defaults. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerCreateCompilerOptionsNative(SpvcCompiler compiler, SpvcCompilerOptions* options)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcCompilerOptions*, SpvcResult>)funcTable[20])(compiler, options);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[20])(compiler, (nint)options);
			#endif
		}

		/// <summary>
		/// Create compiler options, which will initialize defaults. <br/>
		/// </summary>
		public static SpvcResult CompilerCreateCompilerOptions(SpvcCompiler compiler, SpvcCompilerOptions* options)
		{
			SpvcResult ret = CompilerCreateCompilerOptionsNative(compiler, options);
			return ret;
		}

		/// <summary>
		/// Create compiler options, which will initialize defaults. <br/>
		/// </summary>
		public static SpvcResult CompilerCreateCompilerOptions(SpvcCompiler compiler, ref SpvcCompilerOptions options)
		{
			fixed (SpvcCompilerOptions* poptions = &options)
			{
				SpvcResult ret = CompilerCreateCompilerOptionsNative(compiler, (SpvcCompilerOptions*)poptions);
				return ret;
			}
		}

		/// <summary>
		/// Override options. Will return error if e.g. MSL options are used for the HLSL backend, etc. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerOptionsSetBoolNative(SpvcCompilerOptions options, SpvcCompilerOption option, byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompilerOptions, SpvcCompilerOption, byte, SpvcResult>)funcTable[21])(options, option, value);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompilerOptions, SpvcCompilerOption, byte, SpvcResult>)funcTable[21])(options, option, value);
			#endif
		}

		/// <summary>
		/// Override options. Will return error if e.g. MSL options are used for the HLSL backend, etc. <br/>
		/// </summary>
		public static SpvcResult CompilerOptionsSetBool(SpvcCompilerOptions options, SpvcCompilerOption option, bool value)
		{
			SpvcResult ret = CompilerOptionsSetBoolNative(options, option, value ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerOptionsSetUintNative(SpvcCompilerOptions options, SpvcCompilerOption option, uint value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompilerOptions, SpvcCompilerOption, uint, SpvcResult>)funcTable[22])(options, option, value);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompilerOptions, SpvcCompilerOption, uint, SpvcResult>)funcTable[22])(options, option, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerOptionsSetUint(SpvcCompilerOptions options, SpvcCompilerOption option, uint value)
		{
			SpvcResult ret = CompilerOptionsSetUintNative(options, option, value);
			return ret;
		}

		/// <summary>
		/// Set compiler options. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerInstallCompilerOptionsNative(SpvcCompiler compiler, SpvcCompilerOptions options)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcCompilerOptions, SpvcResult>)funcTable[23])(compiler, options);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcCompilerOptions, SpvcResult>)funcTable[23])(compiler, options);
			#endif
		}

		/// <summary>
		/// Set compiler options. <br/>
		/// </summary>
		public static SpvcResult CompilerInstallCompilerOptions(SpvcCompiler compiler, SpvcCompilerOptions options)
		{
			SpvcResult ret = CompilerInstallCompilerOptionsNative(compiler, options);
			return ret;
		}

		/// <summary>
		/// Compile IR into a string. *source is owned by the context, and caller must not free it themselves. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerCompileNative(SpvcCompiler compiler, byte** source)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte**, SpvcResult>)funcTable[24])(compiler, source);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[24])(compiler, (nint)source);
			#endif
		}

		/// <summary>
		/// Compile IR into a string. *source is owned by the context, and caller must not free it themselves. <br/>
		/// </summary>
		public static SpvcResult CompilerCompile(SpvcCompiler compiler, byte** source)
		{
			SpvcResult ret = CompilerCompileNative(compiler, source);
			return ret;
		}

		/// <summary>
		/// Compile IR into a string. *source is owned by the context, and caller must not free it themselves. <br/>
		/// </summary>
		public static SpvcResult CompilerCompile(SpvcCompiler compiler, ref byte* source)
		{
			fixed (byte** psource = &source)
			{
				SpvcResult ret = CompilerCompileNative(compiler, (byte**)psource);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerAddHeaderLineNative(SpvcCompiler compiler, byte* line)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, SpvcResult>)funcTable[25])(compiler, line);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[25])(compiler, (nint)line);
			#endif
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult CompilerAddHeaderLine(SpvcCompiler compiler, byte* line)
		{
			SpvcResult ret = CompilerAddHeaderLineNative(compiler, line);
			return ret;
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult CompilerAddHeaderLine(SpvcCompiler compiler, ref byte line)
		{
			fixed (byte* pline = &line)
			{
				SpvcResult ret = CompilerAddHeaderLineNative(compiler, (byte*)pline);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult CompilerAddHeaderLine(SpvcCompiler compiler, ReadOnlySpan<byte> line)
		{
			fixed (byte* pline = line)
			{
				SpvcResult ret = CompilerAddHeaderLineNative(compiler, (byte*)pline);
				return ret;
			}
		}

		/// <summary>
		/// Maps to C++ API. <br/>
		/// </summary>
		public static SpvcResult CompilerAddHeaderLine(SpvcCompiler compiler, string line)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (line != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(line);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(line, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerAddHeaderLineNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerRequireExtensionNative(SpvcCompiler compiler, byte* ext)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, SpvcResult>)funcTable[26])(compiler, ext);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[26])(compiler, (nint)ext);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRequireExtension(SpvcCompiler compiler, byte* ext)
		{
			SpvcResult ret = CompilerRequireExtensionNative(compiler, ext);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRequireExtension(SpvcCompiler compiler, ref byte ext)
		{
			fixed (byte* pext = &ext)
			{
				SpvcResult ret = CompilerRequireExtensionNative(compiler, (byte*)pext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRequireExtension(SpvcCompiler compiler, ReadOnlySpan<byte> ext)
		{
			fixed (byte* pext = ext)
			{
				SpvcResult ret = CompilerRequireExtensionNative(compiler, (byte*)pext);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRequireExtension(SpvcCompiler compiler, string ext)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (ext != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(ext);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(ext, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerRequireExtensionNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nuint CompilerGetNumRequiredExtensionsNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, nuint>)funcTable[27])(compiler);
			#else
			return (nuint)((delegate* unmanaged[Cdecl]<SpvcCompiler, nuint>)funcTable[27])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static nuint CompilerGetNumRequiredExtensions(SpvcCompiler compiler)
		{
			nuint ret = CompilerGetNumRequiredExtensionsNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetRequiredExtensionNative(SpvcCompiler compiler, nuint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, nuint, byte*>)funcTable[28])(compiler, index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, nuint, nint>)funcTable[28])(compiler, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetRequiredExtension(SpvcCompiler compiler, nuint index)
		{
			byte* ret = CompilerGetRequiredExtensionNative(compiler, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetRequiredExtensionS(SpvcCompiler compiler, nuint index)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetRequiredExtensionNative(compiler, index));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerFlattenBufferBlockNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[29])(compiler, id);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[29])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerFlattenBufferBlock(SpvcCompiler compiler, uint id)
		{
			SpvcResult ret = CompilerFlattenBufferBlockNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerVariableIsDepthOrCompareNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[30])(compiler, id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[30])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerVariableIsDepthOrCompare(SpvcCompiler compiler, uint id)
		{
			byte ret = CompilerVariableIsDepthOrCompareNative(compiler, id);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMaskStageOutputByLocationNative(SpvcCompiler compiler, uint location, uint component)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[31])(compiler, location, component);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[31])(compiler, location, component);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMaskStageOutputByLocation(SpvcCompiler compiler, uint location, uint component)
		{
			SpvcResult ret = CompilerMaskStageOutputByLocationNative(compiler, location, component);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMaskStageOutputByBuiltinNative(SpvcCompiler compiler, SpvBuiltIn builtin)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvBuiltIn, SpvcResult>)funcTable[32])(compiler, builtin);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvBuiltIn, SpvcResult>)funcTable[32])(compiler, builtin);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMaskStageOutputByBuiltin(SpvcCompiler compiler, SpvBuiltIn builtin)
		{
			SpvcResult ret = CompilerMaskStageOutputByBuiltinNative(compiler, builtin);
			return ret;
		}

		/// <summary>
		/// HLSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerHlslSetRootConstantsLayoutNative(SpvcCompiler compiler, SpvcHlslRootConstants* constantInfo, nuint count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcHlslRootConstants*, nuint, SpvcResult>)funcTable[33])(compiler, constantInfo, count);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nuint, SpvcResult>)funcTable[33])(compiler, (nint)constantInfo, count);
			#endif
		}

		/// <summary>
		/// HLSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerHlslSetRootConstantsLayout(SpvcCompiler compiler, SpvcHlslRootConstants* constantInfo, nuint count)
		{
			SpvcResult ret = CompilerHlslSetRootConstantsLayoutNative(compiler, constantInfo, count);
			return ret;
		}

		/// <summary>
		/// HLSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerHlslSetRootConstantsLayout(SpvcCompiler compiler, ref SpvcHlslRootConstants constantInfo, nuint count)
		{
			fixed (SpvcHlslRootConstants* pconstantInfo = &constantInfo)
			{
				SpvcResult ret = CompilerHlslSetRootConstantsLayoutNative(compiler, (SpvcHlslRootConstants*)pconstantInfo, count);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerHlslAddVertexAttributeRemapNative(SpvcCompiler compiler, SpvcHlslVertexAttributeRemap* remap, nuint remaps)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcHlslVertexAttributeRemap*, nuint, SpvcResult>)funcTable[34])(compiler, remap, remaps);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nuint, SpvcResult>)funcTable[34])(compiler, (nint)remap, remaps);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerHlslAddVertexAttributeRemap(SpvcCompiler compiler, SpvcHlslVertexAttributeRemap* remap, nuint remaps)
		{
			SpvcResult ret = CompilerHlslAddVertexAttributeRemapNative(compiler, remap, remaps);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerHlslAddVertexAttributeRemap(SpvcCompiler compiler, ref SpvcHlslVertexAttributeRemap remap, nuint remaps)
		{
			fixed (SpvcHlslVertexAttributeRemap* premap = &remap)
			{
				SpvcResult ret = CompilerHlslAddVertexAttributeRemapNative(compiler, (SpvcHlslVertexAttributeRemap*)premap, remaps);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerHlslRemapNumWorkgroupsBuiltinNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint>)funcTable[35])(compiler);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint>)funcTable[35])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerHlslRemapNumWorkgroupsBuiltin(SpvcCompiler compiler)
		{
			uint ret = CompilerHlslRemapNumWorkgroupsBuiltinNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerHlslSetResourceBindingFlagsNative(SpvcCompiler compiler, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[36])(compiler, flags);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[36])(compiler, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerHlslSetResourceBindingFlags(SpvcCompiler compiler, uint flags)
		{
			SpvcResult ret = CompilerHlslSetResourceBindingFlagsNative(compiler, flags);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerHlslAddResourceBindingNative(SpvcCompiler compiler, SpvcHlslResourceBinding* binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcHlslResourceBinding*, SpvcResult>)funcTable[37])(compiler, binding);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[37])(compiler, (nint)binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerHlslAddResourceBinding(SpvcCompiler compiler, SpvcHlslResourceBinding* binding)
		{
			SpvcResult ret = CompilerHlslAddResourceBindingNative(compiler, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerHlslAddResourceBinding(SpvcCompiler compiler, ref SpvcHlslResourceBinding binding)
		{
			fixed (SpvcHlslResourceBinding* pbinding = &binding)
			{
				SpvcResult ret = CompilerHlslAddResourceBindingNative(compiler, (SpvcHlslResourceBinding*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerHlslIsResourceUsedNative(SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel, uint, uint, byte>)funcTable[38])(compiler, model, set, binding);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel, uint, uint, byte>)funcTable[38])(compiler, model, set, binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerHlslIsResourceUsed(SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			byte ret = CompilerHlslIsResourceUsedNative(compiler, model, set, binding);
			return ret != 0;
		}

		/// <summary>
		/// MSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslIsRasterizationDisabledNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[39])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[39])(compiler);
			#endif
		}

		/// <summary>
		/// MSL specifics.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static bool CompilerMslIsRasterizationDisabled(SpvcCompiler compiler)
		{
			byte ret = CompilerMslIsRasterizationDisabledNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// Obsolete. Renamed to needs_swizzle_buffer. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsAuxBufferNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[40])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[40])(compiler);
			#endif
		}

		/// <summary>
		/// Obsolete. Renamed to needs_swizzle_buffer. <br/>
		/// </summary>
		public static bool CompilerMslNeedsAuxBuffer(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsAuxBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsSwizzleBufferNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[41])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[41])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslNeedsSwizzleBuffer(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsSwizzleBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsBufferSizeBufferNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[42])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[42])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslNeedsBufferSizeBuffer(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsBufferSizeBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsOutputBufferNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[43])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[43])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslNeedsOutputBuffer(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsOutputBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsPatchOutputBufferNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[44])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[44])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslNeedsPatchOutputBuffer(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsPatchOutputBufferNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslNeedsInputThreadgroupMemNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[45])(compiler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, byte>)funcTable[45])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslNeedsInputThreadgroupMem(SpvcCompiler compiler)
		{
			byte ret = CompilerMslNeedsInputThreadgroupMemNative(compiler);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddVertexAttributeNative(SpvcCompiler compiler, SpvcMslVertexAttribute* attrs)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslVertexAttribute*, SpvcResult>)funcTable[46])(compiler, attrs);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[46])(compiler, (nint)attrs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddVertexAttribute(SpvcCompiler compiler, SpvcMslVertexAttribute* attrs)
		{
			SpvcResult ret = CompilerMslAddVertexAttributeNative(compiler, attrs);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddVertexAttribute(SpvcCompiler compiler, ref SpvcMslVertexAttribute attrs)
		{
			fixed (SpvcMslVertexAttribute* pattrs = &attrs)
			{
				SpvcResult ret = CompilerMslAddVertexAttributeNative(compiler, (SpvcMslVertexAttribute*)pattrs);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_resource_binding_2(). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddResourceBindingNative(SpvcCompiler compiler, SpvcMslResourceBinding* binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslResourceBinding*, SpvcResult>)funcTable[47])(compiler, binding);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[47])(compiler, (nint)binding);
			#endif
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_resource_binding_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddResourceBinding(SpvcCompiler compiler, SpvcMslResourceBinding* binding)
		{
			SpvcResult ret = CompilerMslAddResourceBindingNative(compiler, binding);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_resource_binding_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddResourceBinding(SpvcCompiler compiler, ref SpvcMslResourceBinding binding)
		{
			fixed (SpvcMslResourceBinding* pbinding = &binding)
			{
				SpvcResult ret = CompilerMslAddResourceBindingNative(compiler, (SpvcMslResourceBinding*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddResourceBinding2Native(SpvcCompiler compiler, SpvcMslResourceBinding2* binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslResourceBinding2*, SpvcResult>)funcTable[48])(compiler, binding);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[48])(compiler, (nint)binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddResourceBinding2(SpvcCompiler compiler, SpvcMslResourceBinding2* binding)
		{
			SpvcResult ret = CompilerMslAddResourceBinding2Native(compiler, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddResourceBinding2(SpvcCompiler compiler, ref SpvcMslResourceBinding2 binding)
		{
			fixed (SpvcMslResourceBinding2* pbinding = &binding)
			{
				SpvcResult ret = CompilerMslAddResourceBinding2Native(compiler, (SpvcMslResourceBinding2*)pbinding);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_input_2(). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddShaderInputNative(SpvcCompiler compiler, SpvcMslShaderInterfaceVar* input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslShaderInterfaceVar*, SpvcResult>)funcTable[49])(compiler, input);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[49])(compiler, (nint)input);
			#endif
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_input_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddShaderInput(SpvcCompiler compiler, SpvcMslShaderInterfaceVar* input)
		{
			SpvcResult ret = CompilerMslAddShaderInputNative(compiler, input);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_input_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddShaderInput(SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar input)
		{
			fixed (SpvcMslShaderInterfaceVar* pinput = &input)
			{
				SpvcResult ret = CompilerMslAddShaderInputNative(compiler, (SpvcMslShaderInterfaceVar*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddShaderInput2Native(SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslShaderInterfaceVar2*, SpvcResult>)funcTable[50])(compiler, input);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[50])(compiler, (nint)input);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddShaderInput2(SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* input)
		{
			SpvcResult ret = CompilerMslAddShaderInput2Native(compiler, input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddShaderInput2(SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar2 input)
		{
			fixed (SpvcMslShaderInterfaceVar2* pinput = &input)
			{
				SpvcResult ret = CompilerMslAddShaderInput2Native(compiler, (SpvcMslShaderInterfaceVar2*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_output_2(). <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddShaderOutputNative(SpvcCompiler compiler, SpvcMslShaderInterfaceVar* output)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslShaderInterfaceVar*, SpvcResult>)funcTable[51])(compiler, output);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[51])(compiler, (nint)output);
			#endif
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_output_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddShaderOutput(SpvcCompiler compiler, SpvcMslShaderInterfaceVar* output)
		{
			SpvcResult ret = CompilerMslAddShaderOutputNative(compiler, output);
			return ret;
		}

		/// <summary>
		/// Deprecated; use spvc_compiler_msl_add_shader_output_2(). <br/>
		/// </summary>
		public static SpvcResult CompilerMslAddShaderOutput(SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar output)
		{
			fixed (SpvcMslShaderInterfaceVar* poutput = &output)
			{
				SpvcResult ret = CompilerMslAddShaderOutputNative(compiler, (SpvcMslShaderInterfaceVar*)poutput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddShaderOutput2Native(SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* output)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcMslShaderInterfaceVar2*, SpvcResult>)funcTable[52])(compiler, output);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[52])(compiler, (nint)output);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddShaderOutput2(SpvcCompiler compiler, SpvcMslShaderInterfaceVar2* output)
		{
			SpvcResult ret = CompilerMslAddShaderOutput2Native(compiler, output);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddShaderOutput2(SpvcCompiler compiler, ref SpvcMslShaderInterfaceVar2 output)
		{
			fixed (SpvcMslShaderInterfaceVar2* poutput = &output)
			{
				SpvcResult ret = CompilerMslAddShaderOutput2Native(compiler, (SpvcMslShaderInterfaceVar2*)poutput);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddDiscreteDescriptorSetNative(SpvcCompiler compiler, uint descSet)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[53])(compiler, descSet);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcResult>)funcTable[53])(compiler, descSet);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddDiscreteDescriptorSet(SpvcCompiler compiler, uint descSet)
		{
			SpvcResult ret = CompilerMslAddDiscreteDescriptorSetNative(compiler, descSet);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslSetArgumentBufferDeviceAddressSpaceNative(SpvcCompiler compiler, uint descSet, byte deviceAddress)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte, SpvcResult>)funcTable[54])(compiler, descSet, deviceAddress);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte, SpvcResult>)funcTable[54])(compiler, descSet, deviceAddress);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetArgumentBufferDeviceAddressSpace(SpvcCompiler compiler, uint descSet, bool deviceAddress)
		{
			SpvcResult ret = CompilerMslSetArgumentBufferDeviceAddressSpaceNative(compiler, descSet, deviceAddress ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Obsolete, use is_shader_input_used. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslIsVertexAttributeUsedNative(SpvcCompiler compiler, uint location)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[55])(compiler, location);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[55])(compiler, location);
			#endif
		}

		/// <summary>
		/// Obsolete, use is_shader_input_used. <br/>
		/// </summary>
		public static bool CompilerMslIsVertexAttributeUsed(SpvcCompiler compiler, uint location)
		{
			byte ret = CompilerMslIsVertexAttributeUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslIsShaderInputUsedNative(SpvcCompiler compiler, uint location)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[56])(compiler, location);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[56])(compiler, location);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslIsShaderInputUsed(SpvcCompiler compiler, uint location)
		{
			byte ret = CompilerMslIsShaderInputUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslIsShaderOutputUsedNative(SpvcCompiler compiler, uint location)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[57])(compiler, location);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte>)funcTable[57])(compiler, location);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslIsShaderOutputUsed(SpvcCompiler compiler, uint location)
		{
			byte ret = CompilerMslIsShaderOutputUsedNative(compiler, location);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerMslIsResourceUsedNative(SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel, uint, uint, byte>)funcTable[58])(compiler, model, set, binding);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel, uint, uint, byte>)funcTable[58])(compiler, model, set, binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerMslIsResourceUsed(SpvcCompiler compiler, SpvExecutionModel model, uint set, uint binding)
		{
			byte ret = CompilerMslIsResourceUsedNative(compiler, model, set, binding);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslRemapConstexprSamplerNative(SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcMslConstexprSampler*, SpvcResult>)funcTable[59])(compiler, id, sampler);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, nint, SpvcResult>)funcTable[59])(compiler, id, (nint)sampler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSampler(SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler)
		{
			SpvcResult ret = CompilerMslRemapConstexprSamplerNative(compiler, id, sampler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSampler(SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerNative(compiler, id, (SpvcMslConstexprSampler*)psampler);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslRemapConstexprSamplerByBindingNative(SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcMslConstexprSampler*, SpvcResult>)funcTable[60])(compiler, descSet, binding, sampler);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, nint, SpvcResult>)funcTable[60])(compiler, descSet, binding, (nint)sampler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBinding(SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler)
		{
			SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingNative(compiler, descSet, binding, sampler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBinding(SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslRemapConstexprSamplerYcbcrNative(SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcMslConstexprSampler*, SpvcMslSamplerYcbcrConversion*, SpvcResult>)funcTable[61])(compiler, id, sampler, conv);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, nint, nint, SpvcResult>)funcTable[61])(compiler, id, (nint)sampler, (nint)conv);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerYcbcr(SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			SpvcResult ret = CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, sampler, conv);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerYcbcr(SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, (SpvcMslConstexprSampler*)psampler, conv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerYcbcr(SpvcCompiler compiler, uint id, SpvcMslConstexprSampler* sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, sampler, (SpvcMslSamplerYcbcrConversion*)pconv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerYcbcr(SpvcCompiler compiler, uint id, ref SpvcMslConstexprSampler sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
				{
					SpvcResult ret = CompilerMslRemapConstexprSamplerYcbcrNative(compiler, id, (SpvcMslConstexprSampler*)psampler, (SpvcMslSamplerYcbcrConversion*)pconv);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslRemapConstexprSamplerByBindingYcbcrNative(SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcMslConstexprSampler*, SpvcMslSamplerYcbcrConversion*, SpvcResult>)funcTable[62])(compiler, descSet, binding, sampler, conv);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, nint, nint, SpvcResult>)funcTable[62])(compiler, descSet, binding, (nint)sampler, (nint)conv);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBindingYcbcr(SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, sampler, conv);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBindingYcbcr(SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler, SpvcMslSamplerYcbcrConversion* conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler, conv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBindingYcbcr(SpvcCompiler compiler, uint descSet, uint binding, SpvcMslConstexprSampler* sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
			{
				SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, sampler, (SpvcMslSamplerYcbcrConversion*)pconv);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslRemapConstexprSamplerByBindingYcbcr(SpvcCompiler compiler, uint descSet, uint binding, ref SpvcMslConstexprSampler sampler, ref SpvcMslSamplerYcbcrConversion conv)
		{
			fixed (SpvcMslConstexprSampler* psampler = &sampler)
			{
				fixed (SpvcMslSamplerYcbcrConversion* pconv = &conv)
				{
					SpvcResult ret = CompilerMslRemapConstexprSamplerByBindingYcbcrNative(compiler, descSet, binding, (SpvcMslConstexprSampler*)psampler, (SpvcMslSamplerYcbcrConversion*)pconv);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslSetFragmentOutputComponentsNative(SpvcCompiler compiler, uint location, uint components)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[63])(compiler, location, components);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[63])(compiler, location, components);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetFragmentOutputComponents(SpvcCompiler compiler, uint location, uint components)
		{
			SpvcResult ret = CompilerMslSetFragmentOutputComponentsNative(compiler, location, components);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerMslGetAutomaticResourceBindingNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint>)funcTable[64])(compiler, id);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint>)funcTable[64])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerMslGetAutomaticResourceBinding(SpvcCompiler compiler, uint id)
		{
			uint ret = CompilerMslGetAutomaticResourceBindingNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerMslGetAutomaticResourceBindingSecondaryNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint>)funcTable[65])(compiler, id);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint>)funcTable[65])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerMslGetAutomaticResourceBindingSecondary(SpvcCompiler compiler, uint id)
		{
			uint ret = CompilerMslGetAutomaticResourceBindingSecondaryNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddDynamicBufferNative(SpvcCompiler compiler, uint descSet, uint binding, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, uint, SpvcResult>)funcTable[66])(compiler, descSet, binding, index);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, uint, SpvcResult>)funcTable[66])(compiler, descSet, binding, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddDynamicBuffer(SpvcCompiler compiler, uint descSet, uint binding, uint index)
		{
			SpvcResult ret = CompilerMslAddDynamicBufferNative(compiler, descSet, binding, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslAddInlineUniformBlockNative(SpvcCompiler compiler, uint descSet, uint binding)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[67])(compiler, descSet, binding);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvcResult>)funcTable[67])(compiler, descSet, binding);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslAddInlineUniformBlock(SpvcCompiler compiler, uint descSet, uint binding)
		{
			SpvcResult ret = CompilerMslAddInlineUniformBlockNative(compiler, descSet, binding);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerMslSetCombinedSamplerSuffixNative(SpvcCompiler compiler, byte* suffix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, SpvcResult>)funcTable[68])(compiler, suffix);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[68])(compiler, (nint)suffix);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetCombinedSamplerSuffix(SpvcCompiler compiler, byte* suffix)
		{
			SpvcResult ret = CompilerMslSetCombinedSamplerSuffixNative(compiler, suffix);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetCombinedSamplerSuffix(SpvcCompiler compiler, ref byte suffix)
		{
			fixed (byte* psuffix = &suffix)
			{
				SpvcResult ret = CompilerMslSetCombinedSamplerSuffixNative(compiler, (byte*)psuffix);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetCombinedSamplerSuffix(SpvcCompiler compiler, ReadOnlySpan<byte> suffix)
		{
			fixed (byte* psuffix = suffix)
			{
				SpvcResult ret = CompilerMslSetCombinedSamplerSuffixNative(compiler, (byte*)psuffix);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerMslSetCombinedSamplerSuffix(SpvcCompiler compiler, string suffix)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (suffix != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(suffix);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(suffix, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerMslSetCombinedSamplerSuffixNative(compiler, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerMslGetCombinedSamplerSuffixNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*>)funcTable[69])(compiler);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint>)funcTable[69])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerMslGetCombinedSamplerSuffix(SpvcCompiler compiler)
		{
			byte* ret = CompilerMslGetCombinedSamplerSuffixNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerMslGetCombinedSamplerSuffixS(SpvcCompiler compiler)
		{
			string ret = Utils.DecodeStringUTF8(CompilerMslGetCombinedSamplerSuffixNative(compiler));
			return ret;
		}

		/// <summary>
		/// Reflect resources.<br/>
		/// Maps almost 1:1 to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetActiveInterfaceVariablesNative(SpvcCompiler compiler, SpvcSet* set)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcSet*, SpvcResult>)funcTable[70])(compiler, set);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[70])(compiler, (nint)set);
			#endif
		}

		/// <summary>
		/// Reflect resources.<br/>
		/// Maps almost 1:1 to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveInterfaceVariables(SpvcCompiler compiler, SpvcSet* set)
		{
			SpvcResult ret = CompilerGetActiveInterfaceVariablesNative(compiler, set);
			return ret;
		}

		/// <summary>
		/// Reflect resources.<br/>
		/// Maps almost 1:1 to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveInterfaceVariables(SpvcCompiler compiler, ref SpvcSet set)
		{
			fixed (SpvcSet* pset = &set)
			{
				SpvcResult ret = CompilerGetActiveInterfaceVariablesNative(compiler, (SpvcSet*)pset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerSetEnabledInterfaceVariablesNative(SpvcCompiler compiler, SpvcSet set)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcSet, SpvcResult>)funcTable[71])(compiler, set);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcSet, SpvcResult>)funcTable[71])(compiler, set);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerSetEnabledInterfaceVariables(SpvcCompiler compiler, SpvcSet set)
		{
			SpvcResult ret = CompilerSetEnabledInterfaceVariablesNative(compiler, set);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerCreateShaderResourcesNative(SpvcCompiler compiler, SpvcResources* resources)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcResources*, SpvcResult>)funcTable[72])(compiler, resources);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[72])(compiler, (nint)resources);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerCreateShaderResources(SpvcCompiler compiler, SpvcResources* resources)
		{
			SpvcResult ret = CompilerCreateShaderResourcesNative(compiler, resources);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerCreateShaderResources(SpvcCompiler compiler, ref SpvcResources resources)
		{
			fixed (SpvcResources* presources = &resources)
			{
				SpvcResult ret = CompilerCreateShaderResourcesNative(compiler, (SpvcResources*)presources);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerCreateShaderResourcesForActiveVariablesNative(SpvcCompiler compiler, SpvcResources* resources, SpvcSet active)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcResources*, SpvcSet, SpvcResult>)funcTable[73])(compiler, resources, active);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcSet, SpvcResult>)funcTable[73])(compiler, (nint)resources, active);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerCreateShaderResourcesForActiveVariables(SpvcCompiler compiler, SpvcResources* resources, SpvcSet active)
		{
			SpvcResult ret = CompilerCreateShaderResourcesForActiveVariablesNative(compiler, resources, active);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerCreateShaderResourcesForActiveVariables(SpvcCompiler compiler, ref SpvcResources resources, SpvcSet active)
		{
			fixed (SpvcResources* presources = &resources)
			{
				SpvcResult ret = CompilerCreateShaderResourcesForActiveVariablesNative(compiler, (SpvcResources*)presources, active);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult ResourcesGetResourceListForTypeNative(SpvcResources resources, SpvcResourceType type, SpvcReflectedResource** resourceList, nuint* resourceSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcResources, SpvcResourceType, SpvcReflectedResource**, nuint*, SpvcResult>)funcTable[74])(resources, type, resourceList, resourceSize);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcResources, SpvcResourceType, nint, nint, SpvcResult>)funcTable[74])(resources, type, (nint)resourceList, (nint)resourceSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetResourceListForType(SpvcResources resources, SpvcResourceType type, SpvcReflectedResource** resourceList, nuint* resourceSize)
		{
			SpvcResult ret = ResourcesGetResourceListForTypeNative(resources, type, resourceList, resourceSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetResourceListForType(SpvcResources resources, SpvcResourceType type, ref SpvcReflectedResource* resourceList, nuint* resourceSize)
		{
			fixed (SpvcReflectedResource** presourceList = &resourceList)
			{
				SpvcResult ret = ResourcesGetResourceListForTypeNative(resources, type, (SpvcReflectedResource**)presourceList, resourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetResourceListForType(SpvcResources resources, SpvcResourceType type, SpvcReflectedResource** resourceList, ref nuint resourceSize)
		{
			fixed (nuint* presourceSize = &resourceSize)
			{
				SpvcResult ret = ResourcesGetResourceListForTypeNative(resources, type, resourceList, (nuint*)presourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetResourceListForType(SpvcResources resources, SpvcResourceType type, ref SpvcReflectedResource* resourceList, ref nuint resourceSize)
		{
			fixed (SpvcReflectedResource** presourceList = &resourceList)
			{
				fixed (nuint* presourceSize = &resourceSize)
				{
					SpvcResult ret = ResourcesGetResourceListForTypeNative(resources, type, (SpvcReflectedResource**)presourceList, (nuint*)presourceSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult ResourcesGetBuiltinResourceListForTypeNative(SpvcResources resources, SpvcBuiltinResourceType type, SpvcReflectedBuiltinResource** resourceList, nuint* resourceSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcResources, SpvcBuiltinResourceType, SpvcReflectedBuiltinResource**, nuint*, SpvcResult>)funcTable[75])(resources, type, resourceList, resourceSize);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcResources, SpvcBuiltinResourceType, nint, nint, SpvcResult>)funcTable[75])(resources, type, (nint)resourceList, (nint)resourceSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetBuiltinResourceListForType(SpvcResources resources, SpvcBuiltinResourceType type, SpvcReflectedBuiltinResource** resourceList, nuint* resourceSize)
		{
			SpvcResult ret = ResourcesGetBuiltinResourceListForTypeNative(resources, type, resourceList, resourceSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetBuiltinResourceListForType(SpvcResources resources, SpvcBuiltinResourceType type, ref SpvcReflectedBuiltinResource* resourceList, nuint* resourceSize)
		{
			fixed (SpvcReflectedBuiltinResource** presourceList = &resourceList)
			{
				SpvcResult ret = ResourcesGetBuiltinResourceListForTypeNative(resources, type, (SpvcReflectedBuiltinResource**)presourceList, resourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetBuiltinResourceListForType(SpvcResources resources, SpvcBuiltinResourceType type, SpvcReflectedBuiltinResource** resourceList, ref nuint resourceSize)
		{
			fixed (nuint* presourceSize = &resourceSize)
			{
				SpvcResult ret = ResourcesGetBuiltinResourceListForTypeNative(resources, type, resourceList, (nuint*)presourceSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult ResourcesGetBuiltinResourceListForType(SpvcResources resources, SpvcBuiltinResourceType type, ref SpvcReflectedBuiltinResource* resourceList, ref nuint resourceSize)
		{
			fixed (SpvcReflectedBuiltinResource** presourceList = &resourceList)
			{
				fixed (nuint* presourceSize = &resourceSize)
				{
					SpvcResult ret = ResourcesGetBuiltinResourceListForTypeNative(resources, type, (SpvcReflectedBuiltinResource**)presourceList, (nuint*)presourceSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decorations.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetDecorationNative(SpvcCompiler compiler, uint id, SpvDecoration decoration, uint argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, uint, void>)funcTable[76])(compiler, id, decoration, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, uint, void>)funcTable[76])(compiler, id, decoration, argument);
			#endif
		}

		/// <summary>
		/// Decorations.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static void CompilerSetDecoration(SpvcCompiler compiler, uint id, SpvDecoration decoration, uint argument)
		{
			CompilerSetDecorationNative(compiler, id, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetDecorationStringNative(SpvcCompiler compiler, uint id, SpvDecoration decoration, byte* argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, byte*, void>)funcTable[77])(compiler, id, decoration, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, nint, void>)funcTable[77])(compiler, id, decoration, (nint)argument);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetDecorationString(SpvcCompiler compiler, uint id, SpvDecoration decoration, byte* argument)
		{
			CompilerSetDecorationStringNative(compiler, id, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetDecorationString(SpvcCompiler compiler, uint id, SpvDecoration decoration, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				CompilerSetDecorationStringNative(compiler, id, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetDecorationString(SpvcCompiler compiler, uint id, SpvDecoration decoration, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				CompilerSetDecorationStringNative(compiler, id, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetDecorationString(SpvcCompiler compiler, uint id, SpvDecoration decoration, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompilerSetDecorationStringNative(compiler, id, decoration, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetNameNative(SpvcCompiler compiler, uint id, byte* argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte*, void>)funcTable[78])(compiler, id, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, nint, void>)funcTable[78])(compiler, id, (nint)argument);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetName(SpvcCompiler compiler, uint id, byte* argument)
		{
			CompilerSetNameNative(compiler, id, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetName(SpvcCompiler compiler, uint id, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				CompilerSetNameNative(compiler, id, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetName(SpvcCompiler compiler, uint id, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				CompilerSetNameNative(compiler, id, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetName(SpvcCompiler compiler, uint id, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompilerSetNameNative(compiler, id, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetMemberDecorationNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, uint argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, uint, void>)funcTable[79])(compiler, id, memberIndex, decoration, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, uint, void>)funcTable[79])(compiler, id, memberIndex, decoration, argument);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberDecoration(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, uint argument)
		{
			CompilerSetMemberDecorationNative(compiler, id, memberIndex, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetMemberDecorationStringNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, byte* argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, byte*, void>)funcTable[80])(compiler, id, memberIndex, decoration, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, nint, void>)funcTable[80])(compiler, id, memberIndex, decoration, (nint)argument);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberDecorationString(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, byte* argument)
		{
			CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberDecorationString(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberDecorationString(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberDecorationString(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompilerSetMemberDecorationStringNative(compiler, id, memberIndex, decoration, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetMemberNameNative(SpvcCompiler compiler, uint id, uint memberIndex, byte* argument)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, byte*, void>)funcTable[81])(compiler, id, memberIndex, argument);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, nint, void>)funcTable[81])(compiler, id, memberIndex, (nint)argument);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberName(SpvcCompiler compiler, uint id, uint memberIndex, byte* argument)
		{
			CompilerSetMemberNameNative(compiler, id, memberIndex, argument);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberName(SpvcCompiler compiler, uint id, uint memberIndex, ref byte argument)
		{
			fixed (byte* pargument = &argument)
			{
				CompilerSetMemberNameNative(compiler, id, memberIndex, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberName(SpvcCompiler compiler, uint id, uint memberIndex, ReadOnlySpan<byte> argument)
		{
			fixed (byte* pargument = argument)
			{
				CompilerSetMemberNameNative(compiler, id, memberIndex, (byte*)pargument);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetMemberName(SpvcCompiler compiler, uint id, uint memberIndex, string argument)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (argument != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(argument);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(argument, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CompilerSetMemberNameNative(compiler, id, memberIndex, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerUnsetDecorationNative(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, void>)funcTable[82])(compiler, id, decoration);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, void>)funcTable[82])(compiler, id, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerUnsetDecoration(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			CompilerUnsetDecorationNative(compiler, id, decoration);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerUnsetMemberDecorationNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, void>)funcTable[83])(compiler, id, memberIndex, decoration);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, void>)funcTable[83])(compiler, id, memberIndex, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerUnsetMemberDecoration(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			CompilerUnsetMemberDecorationNative(compiler, id, memberIndex, decoration);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerHasDecorationNative(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, byte>)funcTable[84])(compiler, id, decoration);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, byte>)funcTable[84])(compiler, id, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerHasDecoration(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			byte ret = CompilerHasDecorationNative(compiler, id, decoration);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerHasMemberDecorationNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, byte>)funcTable[85])(compiler, id, memberIndex, decoration);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, byte>)funcTable[85])(compiler, id, memberIndex, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerHasMemberDecoration(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			byte ret = CompilerHasMemberDecorationNative(compiler, id, memberIndex, decoration);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetNameNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, byte*>)funcTable[86])(compiler, id);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, nint>)funcTable[86])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetName(SpvcCompiler compiler, uint id)
		{
			byte* ret = CompilerGetNameNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetNameS(SpvcCompiler compiler, uint id)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetNameNative(compiler, id));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetDecorationNative(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, uint>)funcTable[87])(compiler, id, decoration);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, uint>)funcTable[87])(compiler, id, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetDecoration(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			uint ret = CompilerGetDecorationNative(compiler, id, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetDecorationStringNative(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, byte*>)funcTable[88])(compiler, id, decoration);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvDecoration, nint>)funcTable[88])(compiler, id, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetDecorationString(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			byte* ret = CompilerGetDecorationStringNative(compiler, id, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetDecorationStringS(SpvcCompiler compiler, uint id, SpvDecoration decoration)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetDecorationStringNative(compiler, id, decoration));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetMemberDecorationNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, uint>)funcTable[89])(compiler, id, memberIndex, decoration);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, uint>)funcTable[89])(compiler, id, memberIndex, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetMemberDecoration(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			uint ret = CompilerGetMemberDecorationNative(compiler, id, memberIndex, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetMemberDecorationStringNative(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, byte*>)funcTable[90])(compiler, id, memberIndex, decoration);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, SpvDecoration, nint>)funcTable[90])(compiler, id, memberIndex, decoration);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetMemberDecorationString(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			byte* ret = CompilerGetMemberDecorationStringNative(compiler, id, memberIndex, decoration);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetMemberDecorationStringS(SpvcCompiler compiler, uint id, uint memberIndex, SpvDecoration decoration)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetMemberDecorationStringNative(compiler, id, memberIndex, decoration));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetMemberNameNative(SpvcCompiler compiler, uint id, uint memberIndex)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, byte*>)funcTable[91])(compiler, id, memberIndex);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, uint, nint>)funcTable[91])(compiler, id, memberIndex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetMemberName(SpvcCompiler compiler, uint id, uint memberIndex)
		{
			byte* ret = CompilerGetMemberNameNative(compiler, id, memberIndex);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetMemberNameS(SpvcCompiler compiler, uint id, uint memberIndex)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetMemberNameNative(compiler, id, memberIndex));
			return ret;
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetEntryPointsNative(SpvcCompiler compiler, SpvcEntryPoint** entryPoints, nuint* numEntryPoints)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcEntryPoint**, nuint*, SpvcResult>)funcTable[92])(compiler, entryPoints, numEntryPoints);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, SpvcResult>)funcTable[92])(compiler, (nint)entryPoints, (nint)numEntryPoints);
			#endif
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetEntryPoints(SpvcCompiler compiler, SpvcEntryPoint** entryPoints, nuint* numEntryPoints)
		{
			SpvcResult ret = CompilerGetEntryPointsNative(compiler, entryPoints, numEntryPoints);
			return ret;
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetEntryPoints(SpvcCompiler compiler, ref SpvcEntryPoint* entryPoints, nuint* numEntryPoints)
		{
			fixed (SpvcEntryPoint** pentryPoints = &entryPoints)
			{
				SpvcResult ret = CompilerGetEntryPointsNative(compiler, (SpvcEntryPoint**)pentryPoints, numEntryPoints);
				return ret;
			}
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetEntryPoints(SpvcCompiler compiler, SpvcEntryPoint** entryPoints, ref nuint numEntryPoints)
		{
			fixed (nuint* pnumEntryPoints = &numEntryPoints)
			{
				SpvcResult ret = CompilerGetEntryPointsNative(compiler, entryPoints, (nuint*)pnumEntryPoints);
				return ret;
			}
		}

		/// <summary>
		/// Entry points.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetEntryPoints(SpvcCompiler compiler, ref SpvcEntryPoint* entryPoints, ref nuint numEntryPoints)
		{
			fixed (SpvcEntryPoint** pentryPoints = &entryPoints)
			{
				fixed (nuint* pnumEntryPoints = &numEntryPoints)
				{
					SpvcResult ret = CompilerGetEntryPointsNative(compiler, (SpvcEntryPoint**)pentryPoints, (nuint*)pnumEntryPoints);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerSetEntryPointNative(SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, SpvExecutionModel, SpvcResult>)funcTable[93])(compiler, name, model);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvExecutionModel, SpvcResult>)funcTable[93])(compiler, (nint)name, model);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerSetEntryPoint(SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			SpvcResult ret = CompilerSetEntryPointNative(compiler, name, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerSetEntryPoint(SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				SpvcResult ret = CompilerSetEntryPointNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerSetEntryPoint(SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				SpvcResult ret = CompilerSetEntryPointNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerSetEntryPoint(SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerSetEntryPointNative(compiler, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerRenameEntryPointNative(SpvcCompiler compiler, byte* oldName, byte* newName, SpvExecutionModel model)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, byte*, SpvExecutionModel, SpvcResult>)funcTable[94])(compiler, oldName, newName, model);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, SpvExecutionModel, SpvcResult>)funcTable[94])(compiler, (nint)oldName, (nint)newName, model);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, byte* oldName, byte* newName, SpvExecutionModel model)
		{
			SpvcResult ret = CompilerRenameEntryPointNative(compiler, oldName, newName, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, ref byte oldName, byte* newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = &oldName)
			{
				SpvcResult ret = CompilerRenameEntryPointNative(compiler, (byte*)poldName, newName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, ReadOnlySpan<byte> oldName, byte* newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = oldName)
			{
				SpvcResult ret = CompilerRenameEntryPointNative(compiler, (byte*)poldName, newName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, string oldName, byte* newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerRenameEntryPointNative(compiler, pStr0, newName, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, byte* oldName, ref byte newName, SpvExecutionModel model)
		{
			fixed (byte* pnewName = &newName)
			{
				SpvcResult ret = CompilerRenameEntryPointNative(compiler, oldName, (byte*)pnewName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, byte* oldName, ReadOnlySpan<byte> newName, SpvExecutionModel model)
		{
			fixed (byte* pnewName = newName)
			{
				SpvcResult ret = CompilerRenameEntryPointNative(compiler, oldName, (byte*)pnewName, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, byte* oldName, string newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (newName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(newName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(newName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpvcResult ret = CompilerRenameEntryPointNative(compiler, oldName, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, ref byte oldName, ref byte newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = &oldName)
			{
				fixed (byte* pnewName = &newName)
				{
					SpvcResult ret = CompilerRenameEntryPointNative(compiler, (byte*)poldName, (byte*)pnewName, model);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, ReadOnlySpan<byte> oldName, ReadOnlySpan<byte> newName, SpvExecutionModel model)
		{
			fixed (byte* poldName = oldName)
			{
				fixed (byte* pnewName = newName)
				{
					SpvcResult ret = CompilerRenameEntryPointNative(compiler, (byte*)poldName, (byte*)pnewName, model);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerRenameEntryPoint(SpvcCompiler compiler, string oldName, string newName, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (oldName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(oldName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(oldName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (newName != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(newName);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(newName, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			SpvcResult ret = CompilerRenameEntryPointNative(compiler, pStr0, pStr1, model);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* CompilerGetCleansedEntryPointNameNative(SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, byte*, SpvExecutionModel, byte*>)funcTable[95])(compiler, name, model);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvExecutionModel, nint>)funcTable[95])(compiler, (nint)name, model);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetCleansedEntryPointName(SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			byte* ret = CompilerGetCleansedEntryPointNameNative(compiler, name, model);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetCleansedEntryPointNameS(SpvcCompiler compiler, byte* name, SpvExecutionModel model)
		{
			string ret = Utils.DecodeStringUTF8(CompilerGetCleansedEntryPointNameNative(compiler, name, model));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetCleansedEntryPointName(SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				byte* ret = CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetCleansedEntryPointNameS(SpvcCompiler compiler, ref byte name, SpvExecutionModel model)
		{
			fixed (byte* pname = &name)
			{
				string ret = Utils.DecodeStringUTF8(CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetCleansedEntryPointName(SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				byte* ret = CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetCleansedEntryPointNameS(SpvcCompiler compiler, ReadOnlySpan<byte> name, SpvExecutionModel model)
		{
			fixed (byte* pname = name)
			{
				string ret = Utils.DecodeStringUTF8(CompilerGetCleansedEntryPointNameNative(compiler, (byte*)pname, model));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* CompilerGetCleansedEntryPointName(SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = CompilerGetCleansedEntryPointNameNative(compiler, pStr0, model);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string CompilerGetCleansedEntryPointNameS(SpvcCompiler compiler, string name, SpvExecutionModel model)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(CompilerGetCleansedEntryPointNameNative(compiler, pStr0, model));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetExecutionModeNative(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, void>)funcTable[96])(compiler, mode);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, void>)funcTable[96])(compiler, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetExecutionMode(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			CompilerSetExecutionModeNative(compiler, mode);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerUnsetExecutionModeNative(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, void>)funcTable[97])(compiler, mode);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, void>)funcTable[97])(compiler, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerUnsetExecutionMode(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			CompilerUnsetExecutionModeNative(compiler, mode);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerSetExecutionModeWithArgumentsNative(SpvcCompiler compiler, SpvExecutionMode mode, uint arg0, uint arg1, uint arg2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint, uint, uint, void>)funcTable[98])(compiler, mode, arg0, arg1, arg2);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint, uint, uint, void>)funcTable[98])(compiler, mode, arg0, arg1, arg2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerSetExecutionModeWithArguments(SpvcCompiler compiler, SpvExecutionMode mode, uint arg0, uint arg1, uint arg2)
		{
			CompilerSetExecutionModeWithArgumentsNative(compiler, mode, arg0, arg1, arg2);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetExecutionModesNative(SpvcCompiler compiler, SpvExecutionMode** modes, nuint* numModes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode**, nuint*, SpvcResult>)funcTable[99])(compiler, modes, numModes);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, SpvcResult>)funcTable[99])(compiler, (nint)modes, (nint)numModes);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetExecutionModes(SpvcCompiler compiler, SpvExecutionMode** modes, nuint* numModes)
		{
			SpvcResult ret = CompilerGetExecutionModesNative(compiler, modes, numModes);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetExecutionModes(SpvcCompiler compiler, SpvExecutionMode** modes, ref nuint numModes)
		{
			fixed (nuint* pnumModes = &numModes)
			{
				SpvcResult ret = CompilerGetExecutionModesNative(compiler, modes, (nuint*)pnumModes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetExecutionModeArgumentNative(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint>)funcTable[100])(compiler, mode);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint>)funcTable[100])(compiler, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetExecutionModeArgument(SpvcCompiler compiler, SpvExecutionMode mode)
		{
			uint ret = CompilerGetExecutionModeArgumentNative(compiler, mode);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetExecutionModeArgumentByIndexNative(SpvcCompiler compiler, SpvExecutionMode mode, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint, uint>)funcTable[101])(compiler, mode, index);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionMode, uint, uint>)funcTable[101])(compiler, mode, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetExecutionModeArgumentByIndex(SpvcCompiler compiler, SpvExecutionMode mode, uint index)
		{
			uint ret = CompilerGetExecutionModeArgumentByIndexNative(compiler, mode, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvExecutionModel CompilerGetExecutionModelNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel>)funcTable[102])(compiler);
			#else
			return (SpvExecutionModel)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvExecutionModel>)funcTable[102])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvExecutionModel CompilerGetExecutionModel(SpvcCompiler compiler)
		{
			SpvExecutionModel ret = CompilerGetExecutionModelNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompilerUpdateActiveBuiltinsNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<SpvcCompiler, void>)funcTable[103])(compiler);
			#else
			((delegate* unmanaged[Cdecl]<SpvcCompiler, void>)funcTable[103])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CompilerUpdateActiveBuiltins(SpvcCompiler compiler)
		{
			CompilerUpdateActiveBuiltinsNative(compiler);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte CompilerHasActiveBuiltinNative(SpvcCompiler compiler, SpvBuiltIn builtin, SpvStorageClass storage)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvBuiltIn, SpvStorageClass, byte>)funcTable[104])(compiler, builtin, storage);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvBuiltIn, SpvStorageClass, byte>)funcTable[104])(compiler, builtin, storage);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool CompilerHasActiveBuiltin(SpvcCompiler compiler, SpvBuiltIn builtin, SpvStorageClass storage)
		{
			byte ret = CompilerHasActiveBuiltinNative(compiler, builtin, storage);
			return ret != 0;
		}

		/// <summary>
		/// Type query interface.<br/>
		/// Maps to C++ API, except it's read-only.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcType CompilerGetTypeHandleNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcType>)funcTable[105])(compiler, id);
			#else
			return (SpvcType)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcType>)funcTable[105])(compiler, id);
			#endif
		}

		/// <summary>
		/// Type query interface.<br/>
		/// Maps to C++ API, except it's read-only.<br/>
		/// </summary>
		public static SpvcType CompilerGetTypeHandle(SpvcCompiler compiler, uint id)
		{
			SpvcType ret = CompilerGetTypeHandleNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// Pulls out SPIRType::self. This effectively gives the type ID without array or pointer qualifiers.<br/>
		/// This is necessary when reflecting decoration/name information on members of a struct,<br/>
		/// which are placed in the base type, not the qualified type.<br/>
		/// This is similar to spvc_reflected_resource::base_type_id. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetBaseTypeIdNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[106])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[106])(type);
			#endif
		}

		/// <summary>
		/// Pulls out SPIRType::self. This effectively gives the type ID without array or pointer qualifiers.<br/>
		/// This is necessary when reflecting decoration/name information on members of a struct,<br/>
		/// which are placed in the base type, not the qualified type.<br/>
		/// This is similar to spvc_reflected_resource::base_type_id. <br/>
		/// </summary>
		public static uint TypeGetBaseTypeId(SpvcType type)
		{
			uint ret = TypeGetBaseTypeIdNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcBasetype TypeGetBasetypeNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, SpvcBasetype>)funcTable[107])(type);
			#else
			return (SpvcBasetype)((delegate* unmanaged[Cdecl]<SpvcType, SpvcBasetype>)funcTable[107])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcBasetype TypeGetBasetype(SpvcType type)
		{
			SpvcBasetype ret = TypeGetBasetypeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetBitWidthNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[108])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[108])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetBitWidth(SpvcType type)
		{
			uint ret = TypeGetBitWidthNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetVectorSizeNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[109])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[109])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetVectorSize(SpvcType type)
		{
			uint ret = TypeGetVectorSizeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetColumnsNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[110])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[110])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetColumns(SpvcType type)
		{
			uint ret = TypeGetColumnsNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetNumArrayDimensionsNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[111])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[111])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetNumArrayDimensions(SpvcType type)
		{
			uint ret = TypeGetNumArrayDimensionsNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TypeArrayDimensionIsLiteralNative(SpvcType type, uint dimension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint, byte>)funcTable[112])(type, dimension);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcType, uint, byte>)funcTable[112])(type, dimension);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TypeArrayDimensionIsLiteral(SpvcType type, uint dimension)
		{
			byte ret = TypeArrayDimensionIsLiteralNative(type, dimension);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetArrayDimensionNative(SpvcType type, uint dimension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint, uint>)funcTable[113])(type, dimension);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint, uint>)funcTable[113])(type, dimension);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetArrayDimension(SpvcType type, uint dimension)
		{
			uint ret = TypeGetArrayDimensionNative(type, dimension);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetNumMemberTypesNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[114])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[114])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetNumMemberTypes(SpvcType type)
		{
			uint ret = TypeGetNumMemberTypesNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetMemberTypeNative(SpvcType type, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint, uint>)funcTable[115])(type, index);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint, uint>)funcTable[115])(type, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint TypeGetMemberType(SpvcType type, uint index)
		{
			uint ret = TypeGetMemberTypeNative(type, index);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvStorageClass TypeGetStorageClassNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, SpvStorageClass>)funcTable[116])(type);
			#else
			return (SpvStorageClass)((delegate* unmanaged[Cdecl]<SpvcType, SpvStorageClass>)funcTable[116])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvStorageClass TypeGetStorageClass(SpvcType type)
		{
			SpvStorageClass ret = TypeGetStorageClassNative(type);
			return ret;
		}

		/// <summary>
		/// Image type query. <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint TypeGetImageSampledTypeNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[117])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcType, uint>)funcTable[117])(type);
			#endif
		}

		/// <summary>
		/// Image type query. <br/>
		/// </summary>
		public static uint TypeGetImageSampledType(SpvcType type)
		{
			uint ret = TypeGetImageSampledTypeNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvDim TypeGetImageDimensionNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, SpvDim>)funcTable[118])(type);
			#else
			return (SpvDim)((delegate* unmanaged[Cdecl]<SpvcType, SpvDim>)funcTable[118])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvDim TypeGetImageDimension(SpvcType type)
		{
			SpvDim ret = TypeGetImageDimensionNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TypeGetImageIsDepthNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[119])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[119])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TypeGetImageIsDepth(SpvcType type)
		{
			byte ret = TypeGetImageIsDepthNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TypeGetImageArrayedNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[120])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[120])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TypeGetImageArrayed(SpvcType type)
		{
			byte ret = TypeGetImageArrayedNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TypeGetImageMultisampledNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[121])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[121])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TypeGetImageMultisampled(SpvcType type)
		{
			byte ret = TypeGetImageMultisampledNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TypeGetImageIsStorageNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[122])(type);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<SpvcType, byte>)funcTable[122])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool TypeGetImageIsStorage(SpvcType type)
		{
			byte ret = TypeGetImageIsStorageNative(type);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvImageFormat TypeGetImageStorageFormatNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, SpvImageFormat>)funcTable[123])(type);
			#else
			return (SpvImageFormat)((delegate* unmanaged[Cdecl]<SpvcType, SpvImageFormat>)funcTable[123])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvImageFormat TypeGetImageStorageFormat(SpvcType type)
		{
			SpvImageFormat ret = TypeGetImageStorageFormatNative(type);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvAccessQualifier TypeGetImageAccessQualifierNative(SpvcType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcType, SpvAccessQualifier>)funcTable[124])(type);
			#else
			return (SpvAccessQualifier)((delegate* unmanaged[Cdecl]<SpvcType, SpvAccessQualifier>)funcTable[124])(type);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvAccessQualifier TypeGetImageAccessQualifier(SpvcType type)
		{
			SpvAccessQualifier ret = TypeGetImageAccessQualifierNative(type);
			return ret;
		}

		/// <summary>
		/// Buffer layout query.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetDeclaredStructSizeNative(SpvcCompiler compiler, SpvcType structType, nuint* size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, nuint*, SpvcResult>)funcTable[125])(compiler, structType, size);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, nint, SpvcResult>)funcTable[125])(compiler, structType, (nint)size);
			#endif
		}

		/// <summary>
		/// Buffer layout query.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructSize(SpvcCompiler compiler, SpvcType structType, nuint* size)
		{
			SpvcResult ret = CompilerGetDeclaredStructSizeNative(compiler, structType, size);
			return ret;
		}

		/// <summary>
		/// Buffer layout query.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructSize(SpvcCompiler compiler, SpvcType structType, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = CompilerGetDeclaredStructSizeNative(compiler, structType, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetDeclaredStructSizeRuntimeArrayNative(SpvcCompiler compiler, SpvcType structType, nuint arraySize, nuint* size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, nuint, nuint*, SpvcResult>)funcTable[126])(compiler, structType, arraySize, size);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, nuint, nint, SpvcResult>)funcTable[126])(compiler, structType, arraySize, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructSizeRuntimeArray(SpvcCompiler compiler, SpvcType structType, nuint arraySize, nuint* size)
		{
			SpvcResult ret = CompilerGetDeclaredStructSizeRuntimeArrayNative(compiler, structType, arraySize, size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructSizeRuntimeArray(SpvcCompiler compiler, SpvcType structType, nuint arraySize, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = CompilerGetDeclaredStructSizeRuntimeArrayNative(compiler, structType, arraySize, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetDeclaredStructMemberSizeNative(SpvcCompiler compiler, SpvcType type, uint index, nuint* size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, nuint*, SpvcResult>)funcTable[127])(compiler, type, index, size);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, nint, SpvcResult>)funcTable[127])(compiler, type, index, (nint)size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructMemberSize(SpvcCompiler compiler, SpvcType type, uint index, nuint* size)
		{
			SpvcResult ret = CompilerGetDeclaredStructMemberSizeNative(compiler, type, index, size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetDeclaredStructMemberSize(SpvcCompiler compiler, SpvcType type, uint index, ref nuint size)
		{
			fixed (nuint* psize = &size)
			{
				SpvcResult ret = CompilerGetDeclaredStructMemberSizeNative(compiler, type, index, (nuint*)psize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerTypeStructMemberOffsetNative(SpvcCompiler compiler, SpvcType type, uint index, uint* offset)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, uint*, SpvcResult>)funcTable[128])(compiler, type, index, offset);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, nint, SpvcResult>)funcTable[128])(compiler, type, index, (nint)offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberOffset(SpvcCompiler compiler, SpvcType type, uint index, uint* offset)
		{
			SpvcResult ret = CompilerTypeStructMemberOffsetNative(compiler, type, index, offset);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberOffset(SpvcCompiler compiler, SpvcType type, uint index, ref uint offset)
		{
			fixed (uint* poffset = &offset)
			{
				SpvcResult ret = CompilerTypeStructMemberOffsetNative(compiler, type, index, (uint*)poffset);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerTypeStructMemberArrayStrideNative(SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, uint*, SpvcResult>)funcTable[129])(compiler, type, index, stride);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, nint, SpvcResult>)funcTable[129])(compiler, type, index, (nint)stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberArrayStride(SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			SpvcResult ret = CompilerTypeStructMemberArrayStrideNative(compiler, type, index, stride);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberArrayStride(SpvcCompiler compiler, SpvcType type, uint index, ref uint stride)
		{
			fixed (uint* pstride = &stride)
			{
				SpvcResult ret = CompilerTypeStructMemberArrayStrideNative(compiler, type, index, (uint*)pstride);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerTypeStructMemberMatrixStrideNative(SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, uint*, SpvcResult>)funcTable[130])(compiler, type, index, stride);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcType, uint, nint, SpvcResult>)funcTable[130])(compiler, type, index, (nint)stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberMatrixStride(SpvcCompiler compiler, SpvcType type, uint index, uint* stride)
		{
			SpvcResult ret = CompilerTypeStructMemberMatrixStrideNative(compiler, type, index, stride);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerTypeStructMemberMatrixStride(SpvcCompiler compiler, SpvcType type, uint index, ref uint stride)
		{
			fixed (uint* pstride = &stride)
			{
				SpvcResult ret = CompilerTypeStructMemberMatrixStrideNative(compiler, type, index, (uint*)pstride);
				return ret;
			}
		}

		/// <summary>
		/// Workaround helper functions.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerBuildDummySamplerForCombinedImagesNative(SpvcCompiler compiler, uint* id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint*, SpvcResult>)funcTable[131])(compiler, id);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, SpvcResult>)funcTable[131])(compiler, (nint)id);
			#endif
		}

		/// <summary>
		/// Workaround helper functions.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerBuildDummySamplerForCombinedImages(SpvcCompiler compiler, uint* id)
		{
			SpvcResult ret = CompilerBuildDummySamplerForCombinedImagesNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// Workaround helper functions.<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerBuildDummySamplerForCombinedImages(SpvcCompiler compiler, ref uint id)
		{
			fixed (uint* pid = &id)
			{
				SpvcResult ret = CompilerBuildDummySamplerForCombinedImagesNative(compiler, (uint*)pid);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerBuildCombinedImageSamplersNative(SpvcCompiler compiler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcResult>)funcTable[132])(compiler);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcResult>)funcTable[132])(compiler);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerBuildCombinedImageSamplers(SpvcCompiler compiler)
		{
			SpvcResult ret = CompilerBuildCombinedImageSamplersNative(compiler);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetCombinedImageSamplersNative(SpvcCompiler compiler, SpvcCombinedImageSampler** samplers, nuint* numSamplers)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcCombinedImageSampler**, nuint*, SpvcResult>)funcTable[133])(compiler, samplers, numSamplers);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, SpvcResult>)funcTable[133])(compiler, (nint)samplers, (nint)numSamplers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetCombinedImageSamplers(SpvcCompiler compiler, SpvcCombinedImageSampler** samplers, nuint* numSamplers)
		{
			SpvcResult ret = CompilerGetCombinedImageSamplersNative(compiler, samplers, numSamplers);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetCombinedImageSamplers(SpvcCompiler compiler, ref SpvcCombinedImageSampler* samplers, nuint* numSamplers)
		{
			fixed (SpvcCombinedImageSampler** psamplers = &samplers)
			{
				SpvcResult ret = CompilerGetCombinedImageSamplersNative(compiler, (SpvcCombinedImageSampler**)psamplers, numSamplers);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetCombinedImageSamplers(SpvcCompiler compiler, SpvcCombinedImageSampler** samplers, ref nuint numSamplers)
		{
			fixed (nuint* pnumSamplers = &numSamplers)
			{
				SpvcResult ret = CompilerGetCombinedImageSamplersNative(compiler, samplers, (nuint*)pnumSamplers);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcResult CompilerGetCombinedImageSamplers(SpvcCompiler compiler, ref SpvcCombinedImageSampler* samplers, ref nuint numSamplers)
		{
			fixed (SpvcCombinedImageSampler** psamplers = &samplers)
			{
				fixed (nuint* pnumSamplers = &numSamplers)
				{
					SpvcResult ret = CompilerGetCombinedImageSamplersNative(compiler, (SpvcCombinedImageSampler**)psamplers, (nuint*)pnumSamplers);
					return ret;
				}
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetSpecializationConstantsNative(SpvcCompiler compiler, SpvcSpecializationConstant** constants, nuint* numConstants)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcSpecializationConstant**, nuint*, SpvcResult>)funcTable[134])(compiler, constants, numConstants);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, SpvcResult>)funcTable[134])(compiler, (nint)constants, (nint)numConstants);
			#endif
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant** constants, nuint* numConstants)
		{
			SpvcResult ret = CompilerGetSpecializationConstantsNative(compiler, constants, numConstants);
			return ret;
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant* constants, nuint* numConstants)
		{
			fixed (SpvcSpecializationConstant** pconstants = &constants)
			{
				SpvcResult ret = CompilerGetSpecializationConstantsNative(compiler, (SpvcSpecializationConstant**)pconstants, numConstants);
				return ret;
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant** constants, ref nuint numConstants)
		{
			fixed (nuint* pnumConstants = &numConstants)
			{
				SpvcResult ret = CompilerGetSpecializationConstantsNative(compiler, constants, (nuint*)pnumConstants);
				return ret;
			}
		}

		/// <summary>
		/// Constants<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant* constants, ref nuint numConstants)
		{
			fixed (SpvcSpecializationConstant** pconstants = &constants)
			{
				fixed (nuint* pnumConstants = &numConstants)
				{
					SpvcResult ret = CompilerGetSpecializationConstantsNative(compiler, (SpvcSpecializationConstant**)pconstants, (nuint*)pnumConstants);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcConstant CompilerGetConstantHandleNative(SpvcCompiler compiler, uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcConstant>)funcTable[135])(compiler, id);
			#else
			return (SpvcConstant)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcConstant>)funcTable[135])(compiler, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static SpvcConstant CompilerGetConstantHandle(SpvcCompiler compiler, uint id)
		{
			SpvcConstant ret = CompilerGetConstantHandleNative(compiler, id);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompilerGetWorkGroupSizeSpecializationConstantsNative(SpvcCompiler compiler, SpvcSpecializationConstant* x, SpvcSpecializationConstant* y, SpvcSpecializationConstant* z)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, SpvcSpecializationConstant*, SpvcSpecializationConstant*, SpvcSpecializationConstant*, uint>)funcTable[136])(compiler, x, y, z);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcCompiler, nint, nint, nint, uint>)funcTable[136])(compiler, (nint)x, (nint)y, (nint)z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant* x, SpvcSpecializationConstant* y, SpvcSpecializationConstant* z)
		{
			uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, y, z);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant x, SpvcSpecializationConstant* y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, y, z);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant* x, ref SpvcSpecializationConstant y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* py = &y)
			{
				uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, (SpvcSpecializationConstant*)py, z);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant x, ref SpvcSpecializationConstant y, SpvcSpecializationConstant* z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* py = &y)
				{
					uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, (SpvcSpecializationConstant*)py, z);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant* x, SpvcSpecializationConstant* y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* pz = &z)
			{
				uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, y, (SpvcSpecializationConstant*)pz);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant x, SpvcSpecializationConstant* y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* pz = &z)
				{
					uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, y, (SpvcSpecializationConstant*)pz);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, SpvcSpecializationConstant* x, ref SpvcSpecializationConstant y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* py = &y)
			{
				fixed (SpvcSpecializationConstant* pz = &z)
				{
					uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, x, (SpvcSpecializationConstant*)py, (SpvcSpecializationConstant*)pz);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint CompilerGetWorkGroupSizeSpecializationConstants(SpvcCompiler compiler, ref SpvcSpecializationConstant x, ref SpvcSpecializationConstant y, ref SpvcSpecializationConstant z)
		{
			fixed (SpvcSpecializationConstant* px = &x)
			{
				fixed (SpvcSpecializationConstant* py = &y)
				{
					fixed (SpvcSpecializationConstant* pz = &z)
					{
						uint ret = CompilerGetWorkGroupSizeSpecializationConstantsNative(compiler, (SpvcSpecializationConstant*)px, (SpvcSpecializationConstant*)py, (SpvcSpecializationConstant*)pz);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SpvcResult CompilerGetActiveBufferRangesNative(SpvcCompiler compiler, uint id, SpvcBufferRange** ranges, nuint* numRanges)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, SpvcBufferRange**, nuint*, SpvcResult>)funcTable[137])(compiler, id, ranges, numRanges);
			#else
			return (SpvcResult)((delegate* unmanaged[Cdecl]<SpvcCompiler, uint, nint, nint, SpvcResult>)funcTable[137])(compiler, id, (nint)ranges, (nint)numRanges);
			#endif
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveBufferRanges(SpvcCompiler compiler, uint id, SpvcBufferRange** ranges, nuint* numRanges)
		{
			SpvcResult ret = CompilerGetActiveBufferRangesNative(compiler, id, ranges, numRanges);
			return ret;
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveBufferRanges(SpvcCompiler compiler, uint id, ref SpvcBufferRange* ranges, nuint* numRanges)
		{
			fixed (SpvcBufferRange** pranges = &ranges)
			{
				SpvcResult ret = CompilerGetActiveBufferRangesNative(compiler, id, (SpvcBufferRange**)pranges, numRanges);
				return ret;
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveBufferRanges(SpvcCompiler compiler, uint id, SpvcBufferRange** ranges, ref nuint numRanges)
		{
			fixed (nuint* pnumRanges = &numRanges)
			{
				SpvcResult ret = CompilerGetActiveBufferRangesNative(compiler, id, ranges, (nuint*)pnumRanges);
				return ret;
			}
		}

		/// <summary>
		/// Buffer ranges<br/>
		/// Maps to C++ API.<br/>
		/// </summary>
		public static SpvcResult CompilerGetActiveBufferRanges(SpvcCompiler compiler, uint id, ref SpvcBufferRange* ranges, ref nuint numRanges)
		{
			fixed (SpvcBufferRange** pranges = &ranges)
			{
				fixed (nuint* pnumRanges = &numRanges)
				{
					SpvcResult ret = CompilerGetActiveBufferRangesNative(compiler, id, (SpvcBufferRange**)pranges, (nuint*)pnumRanges);
					return ret;
				}
			}
		}

		/// <summary>
		/// No stdint.h until C99, sigh :(<br/>
		/// For smaller types, the result is sign or zero-extended as appropriate.<br/>
		/// Maps to C++ API.<br/>
		/// TODO: The SPIRConstant query interface and modification interface is not quite complete.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ConstantGetScalarFp16Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, float>)funcTable[138])(constant, column, row);
			#else
			return (float)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, float>)funcTable[138])(constant, column, row);
			#endif
		}

		/// <summary>
		/// No stdint.h until C99, sigh :(<br/>
		/// For smaller types, the result is sign or zero-extended as appropriate.<br/>
		/// Maps to C++ API.<br/>
		/// TODO: The SPIRConstant query interface and modification interface is not quite complete.<br/>
		/// </summary>
		public static float ConstantGetScalarFp16(SpvcConstant constant, uint column, uint row)
		{
			float ret = ConstantGetScalarFp16Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ConstantGetScalarFp32Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, float>)funcTable[139])(constant, column, row);
			#else
			return (float)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, float>)funcTable[139])(constant, column, row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static float ConstantGetScalarFp32(SpvcConstant constant, uint column, uint row)
		{
			float ret = ConstantGetScalarFp32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double ConstantGetScalarFp64Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, double>)funcTable[140])(constant, column, row);
			#else
			return (double)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, double>)funcTable[140])(constant, column, row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static double ConstantGetScalarFp64(SpvcConstant constant, uint column, uint row)
		{
			double ret = ConstantGetScalarFp64Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ConstantGetScalarU32Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, uint>)funcTable[141])(constant, column, row);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, uint>)funcTable[141])(constant, column, row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ConstantGetScalarU32(SpvcConstant constant, uint column, uint row)
		{
			uint ret = ConstantGetScalarU32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ConstantGetScalarI32Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, int>)funcTable[142])(constant, column, row);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, int>)funcTable[142])(constant, column, row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ConstantGetScalarI32(SpvcConstant constant, uint column, uint row)
		{
			int ret = ConstantGetScalarI32Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ConstantGetScalarU16Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, uint>)funcTable[143])(constant, column, row);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, uint>)funcTable[143])(constant, column, row);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ConstantGetScalarU16(SpvcConstant constant, uint column, uint row)
		{
			uint ret = ConstantGetScalarU16Native(constant, column, row);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ConstantGetScalarI16Native(SpvcConstant constant, uint column, uint row)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, int>)funcTable[144])(constant, column, row);
			#else
			return (int)((delegate* unmanaged[Cdecl]<SpvcConstant, uint, uint, int>)funcTable[144])(constant, column, row);
			#endif
		}
	}
}
